<?php
use Symfony\Component\HttpKernel\DataCollector\LateDataCollectorInterface;
//==============================================================================
//===   omoccurrences.php                         
//===   Autogenerated by Druid from MySQL db Build:1
//==============================================================================

/** This file contains a PDO class for omoccurrences.  If a schema change alters 
  * omoccurrences, that change MUST be reflected in this class, or code which
  * uses this file may fail in unpredicatble ways.
  * 
  * See the comments inside OmOccurrences.checkSchema for guidance on how to 
  * update this file for new Symbiota schema versions.
  */

// Up to date with schema version 1.0

include_once($SERVER_ROOT.'/config/dbconnection.php');
$connection = MySQLiConnectionFactory::getCon("write");

class OmOccurrences  {
	
 const DEBUG = true;

 /** 
  * Test to see if this class version is compatible with the current schema version.
  *
  * @see config/schema/utf8/db_schema_patch_1.0.template.sql
  */
 public function checkSchema() {
        global $connection;
        $result = false;

        /*****  Warning: Do not override this check in order to supress error messages.
         *****  If this warning is encountered, this class must be updated, or code that
         *****  invokes it may fail in unpredictable ways. */

        // $supportedVersions[] = '0.9.1.12';         
        // $supportedVersions[] = '0.9.1.13';  // Fields added between 0.9.1.13 and 0.9.1.14
        // $supportedVersions[] = '0.9.1.14';         
        // $supportedVersions[] = '0.9.1.15';            
        $supportedVersions[] = '0.9.1.16';
        $supportedVersions[] = '1.0';
        $supportedVersions[] = '1.1';
        
        /* 
            When the schema version changes, this class must be updated.  There are two cases:

            (1) If the schema change involves no changes to omoccurrences, then you only need
                to add the current schema version to the array of supportedVersions.

            (2) If the schema change involves any change to omoccurrences, that change must
                be reflected in this file before you add the current schema version to the 
                array of supportedVersions, in which case you should also remove any other 
                entries from supportedVersions, as only this latest change will be supported 
                by this file.  

                (I) If a field is added to omoccurrences, you have two options.  You may regenerate 
                this file using druid, and add the extensions to the class OmOccurrences 
                that are listed below (under section IV) back into that class, or you may 
                make the following changes by hand to this file: 

                  For new field omoccurrences.fieldname varchar(10) add the following: 
                
                  // add constants to describe the field.
                  const FIELDNAME_SIZE = 10; 
                  const FIELDNAME             = 'fieldname';

                  // add a private field to OmOccurences.
                  private $fieldname; 
 
                  // add fieldname to  FIELDLIST.
                  const FIELDLIST = ' occid, .... fieldname ';

                  // add fieldname to allFieldsArray.
                  private $allFieldsArray = array( 0 => 'occid' , ... n => 'fieldname' ) ;

                  // set a null default value for fieldname in constructor function OmOccurrences()
                  $this->fieldname = NULL;

                  // in function loadByDwcTriplet() add fieldname to the query and to the bind_results
                  // position is important, easyest is to add field to end of list.
                  $preparesql = 'SELECT occid, ... , fieldname FROM omoccurrences ...
                  $statement->bind_result($this->occid, ... $this->fieldname);

                  // in function loadByCollidCatalog() add fieldname to the query and to the bind_results
                  // position is important, easyest is to add field to end of list.
                  $preparesql = 'SELECT occid, ... , fieldname FROM omoccurrences ...
                  $statement->bind_result($this->occid, ... $this->fieldname);

                  // add fieldname as a case inside function keyValueSet()
                  if ($fieldname=='fieldname') { $returnvalue = $this->setfieldname($value); }/
                  s/^\(.*\)$/             if ($fieldname=='\1') { $returnvalue = $this->set\1($value); }/

                  // add fieldname as a case inside function keyGet()
                  if ($fieldname=='fieldname') { $returnvalue = $this->getfieldname(); }/
                  s/^\(.*\)$/             if ($fieldname=='\1') { $returnvalue = $this->get\1($value); }/

                  // add getter and setter methods to OmOccurrences for fieldname
                  public function getfieldname() {
                      if ($this->fieldname==null) {
                         return null;
                      } else { ;
                         return trim($this->l_stripslashes($this->fieldname));
                      }
                  }
                  public function setfieldname($fieldname) {
                      if (strlen($fieldname) > omoccurrences::FIELDNAME_SIZE) {
                          throw new Exception('Value exceeds field length.');
                      }
                      $this->fieldname = $this->l_addslashes($fieldname);
                      $this->dirty = true;
                  }

                  // add an appropriate (i for integer, d for decimal, s for everything else) MYSQL_TYPE constant
                  const C_fieldnameMYSQLI_TYPE='s';

                  // add fieldname to MySQLiFieldType()
                  if ($aFieldname=='fieldname') { $retval = self::C_fieldnameMYSQLI_TYPE; }
    
                  // add fieldname to select query and to bind_result load() 
                  // position is important, easyest is to add field to end of list.
                  $preparesql = 'SELECT occid, ... , fieldname FROM omoccurrences ...
                  $statement->bind_result($this->occid, ... $this->fieldname);
                  
                  // Then, the trickyest step to get right, given the long lists of fields, 
                  //   note carefully that field order matters and must correlate in the query, 
                  //   fieldtype string in bind_param and list of variables in bind_param.
                  //
                  // add fieldname to save() 
                  // it is easyest to add fieldname as the last field in the list for each statement
                  // (A) to the update query 
                  $sql .= ",  storageLocation = ? "; 
                  // (B) to the insert query
                  $sql .= '( collid , .... fieldname ) VALUES (';
                  // (C) with a placeholder ? in the insert query
                  $sql .=  " ,  ? ";
                  // (D) to both bind_param statements in both the list of field types and the list of fields
                  // in the first (update) bind_param statement, occid must come last
                  $statement->bind_param("i...si", ... $this->fieldname, $this->occid );
                  // in the second (insert) bind_param statement, put fieldname last (or in the same position as in the insert the query)
                  $statement->bind_param("i...s", ... $this->fieldname );

                  // optinally, if appropriate, you may add a select distinct method for fieldname
                  function selectDistinctfielname()
                  // and add a reference to that function in keySelectDistinct();

                (II) If a field is deleted from omoccurrences, all references to it must be removed
                from this file, following the list above for addition of a field.

                (III) If a field is moved from omoccurrences to another table in Symbiota, non-trivial
                work may be involved in supporting that move if any client of the OmOccurrence 
                class methods uses that field.  The likely course to follow will probably be 
                removal 

                (IV) List of additions to the OmOccurrences class that must be added if this file
                is regenerated with Druid:

                Class name OmOccurrences is case sensitive.
               
                Add the following methods to OmOccurrences
                checkSchema()
                loadByDwcTriplet() 
                loadByCollidCatalog()
                lookupCollId()
                lookupInstitutionCode()

                Add the following fields which have no implementation in Symbiota to OmOccurences,
                along with getter and setter methods.
                public $dateSerialized;
                public $serializedBy;
                public $collectorid; 
                public $documentGuid;
                public $documentDate;
                public $fundingSource;
                private $taxonGuid;

        */

         
        // Find the most recently applied version number
        $preparesql = "select versionnumber from schemaversion order by dateapplied desc limit 1;";
        if ($statement = $connection->prepare($preparesql)) {
            $statement->execute();
            $statement->bind_result($versionnumber);
            $statement->fetch();
            if (in_array($versionnumber,$supportedVersions)) {
               $result = true;
            } 
       }
       return $result;
 }

/*

CREATE TABLE `omoccurrences` (
  `occid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `collid` int(10) unsigned NOT NULL,
  `dbpk` varchar(150) DEFAULT NULL,
  `basisOfRecord` varchar(32) DEFAULT 'PreservedSpecimen' COMMENT 'PreservedSpecimen, LivingSpecimen, HumanObservation',
  `occurrenceID` varchar(255) DEFAULT NULL COMMENT 'UniqueGlobalIdentifier',
  `catalogNumber` varchar(32) DEFAULT NULL,
  `otherCatalogNumbers` varchar(255) DEFAULT NULL,
  `ownerInstitutionCode` varchar(32) DEFAULT NULL,
  `institutionID` varchar(255) DEFAULT NULL,
  `collectionID` varchar(255) DEFAULT NULL,
  `datasetID` varchar(255) DEFAULT NULL,
  `institutionCode` varchar(64) DEFAULT NULL,
  `collectionCode` varchar(64) DEFAULT NULL,
  `family` varchar(255) DEFAULT NULL,
  `scientificName` varchar(255) DEFAULT NULL,
  `sciname` varchar(255) DEFAULT NULL,
  `tidinterpreted` int(10) unsigned DEFAULT NULL,
  `genus` varchar(255) DEFAULT NULL,
  `specificEpithet` varchar(255) DEFAULT NULL,
  `taxonRank` varchar(32) DEFAULT NULL,
  `infraspecificEpithet` varchar(255) DEFAULT NULL,
  `scientificNameAuthorship` varchar(255) DEFAULT NULL,
  `taxonRemarks` text,
  `identifiedBy` varchar(255) DEFAULT NULL,
  `dateIdentified` varchar(45) DEFAULT NULL,
  `identificationReferences` text,
  `identificationRemarks` text,
  `identificationQualifier` varchar(255) DEFAULT NULL COMMENT 'cf, aff, etc',
  `typeStatus` varchar(255) DEFAULT NULL,
  `recordedBy` varchar(255) DEFAULT NULL COMMENT 'Collector(s)',
  `recordNumber` varchar(45) DEFAULT NULL COMMENT 'Collector Number',
  `recordedById` int(10) unsigned DEFAULT NULL,
  `associatedCollectors` varchar(255) DEFAULT NULL COMMENT 'not DwC',
  `eventDate` date DEFAULT NULL,
  `latestDateCollected` date DEFAULT NULL,
  `year` int(10) DEFAULT NULL,
  `month` int(10) DEFAULT NULL,
  `day` int(10) DEFAULT NULL,
  `startDayOfYear` int(10) DEFAULT NULL,
  `endDayOfYear` int(10) DEFAULT NULL,
  `verbatimEventDate` varchar(255) DEFAULT NULL,
  `habitat` text COMMENT 'Habitat, substrait, etc',
  `substrate` varchar(500) DEFAULT NULL,
  `fieldNotes` text,
  `fieldnumber` varchar(45) DEFAULT NULL,
  `eventID` varchar(45) DEFAULT NULL,
  `occurrenceRemarks` text COMMENT 'General Notes',
  `informationWithheld` varchar(250) DEFAULT NULL,
  `dataGeneralizations` varchar(250) DEFAULT NULL,
  `associatedOccurrences` text,
  `associatedTaxa` text COMMENT 'Associated Species',
  `dynamicProperties` text,
  `verbatimAttributes` text,
  `behavior` varchar(500) DEFAULT NULL, 
  `reproductiveCondition` varchar(255) DEFAULT NULL COMMENT 'Phenology: flowers, fruit, sterile',
  `cultivationStatus` int(10) DEFAULT NULL COMMENT '0 = wild, 1 = cultivated',
  `establishmentMeans` varchar(150) DEFAULT NULL COMMENT 'cultivated, invasive, escaped from captivity, wild, native',
  `lifeStage` varchar(45) DEFAULT NULL,
  `sex` varchar(45) DEFAULT NULL,
  `individualCount` varchar(45) DEFAULT NULL,
  `samplingProtocol` varchar(100) DEFAULT NULL,
  `samplingEffort` varchar(200) DEFAULT NULL,
  `preparations` varchar(100) DEFAULT NULL,
  `locationID` varchar(100) DEFAULT NULL,
  `waterBody` varchar(255) DEFAULT NULL,
  `country` varchar(64) DEFAULT NULL,
  `stateProvince` varchar(255) DEFAULT NULL,
  `county` varchar(255) DEFAULT NULL,
  `municipality` varchar(255) DEFAULT NULL,
  `locality` text,
  `localitySecurity` int(10) DEFAULT '0' COMMENT '0 = no security; 1 = hidden locality',
  `localitySecurityReason` varchar(100) DEFAULT NULL,
  `decimalLatitude` double DEFAULT NULL,
  `decimalLongitude` double DEFAULT NULL,
  `geodeticDatum` varchar(255) DEFAULT NULL,
  `coordinateUncertaintyInMeters` int(10) unsigned DEFAULT NULL,
  `footprintWKT` text,
  `coordinatePrecision` decimal(9,7) DEFAULT NULL,
  `locationRemarks` text,
  `verbatimCoordinates` varchar(255) DEFAULT NULL,
  `verbatimCoordinateSystem` varchar(255) DEFAULT NULL,
  `georeferencedBy` varchar(255) DEFAULT NULL,
  `georeferenceProtocol` varchar(255) DEFAULT NULL,
  `georeferenceSources` varchar(255) DEFAULT NULL,
  `georeferenceVerificationStatus` varchar(32) DEFAULT NULL,
  `georeferenceRemarks` varchar(255) DEFAULT NULL,
  `minimumElevationInMeters` int(6) DEFAULT NULL,
  `maximumElevationInMeters` int(6) DEFAULT NULL,
  `verbatimElevation` varchar(255) DEFAULT NULL,
  `previousIdentifications` text,
  `disposition` varchar(250) DEFAULT NULL,
  `genericcolumn1` varchar(100) DEFAULT NULL,
  `genericcolumn2` varchar(100) DEFAULT NULL,
  `modified` datetime DEFAULT NULL COMMENT 'DateLastModified',
  `language` varchar(20) DEFAULT NULL,
  `observeruid` int(10) unsigned DEFAULT NULL,
  `processingstatus` varchar(45) DEFAULT NULL,
  `recordEnteredBy` varchar(250) DEFAULT NULL,
  `duplicateQuantity` int(10) unsigned DEFAULT NULL,
  `labelProject` varchar(50) DEFAULT NULL,
  `dynamicFields` text DEFAULT NULL,
  `dateEntered` datetime DEFAULT NULL,
  `dateLastModified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`occid`) USING BTREE,
  UNIQUE KEY `Index_collid` (`collid`,`dbpk`),
  KEY `Index_sciname` (`sciname`),
  KEY `Index_family` (`family`),
  KEY `Index_country` (`country`),
  KEY `Index_state` (`stateProvince`),
  KEY `Index_county` (`county`),
  KEY `Index_collector` (`recordedBy`),
  KEY `Index_gui` (`occurrenceID`),
  KEY `Index_ownerInst` (`ownerInstitutionCode`),
  KEY `FK_omoccurrences_tid` (`tidinterpreted`),
  KEY `FK_omoccurrences_uid` (`observeruid`),
  KEY `Index_municipality` (`municipality`),
  KEY `Index_collnum` (`recordNumber`),
  KEY `Index_catalognumber` (`catalogNumber`),
  KEY `FK_recordedbyid` (`recordedById`),
  KEY `Index_eventDate` (`eventDate`),
  KEY `Index_occurrences_procstatus` (`processingstatus`),
  KEY `Index_locality` (`locality`(100)),
  KEY `Index_otherCatalogNumbers` (`otherCatalogNumbers`),
  KEY `Index_latestDateCollected` (`latestDateCollected`),
  CONSTRAINT `FK_omoccurrences_collid` FOREIGN KEY (`collid`) REFERENCES `omcollections` (`CollID`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `FK_omoccurrences_recbyid` FOREIGN KEY (`recordedById`) REFERENCES `agents` (`agentId`) ON DELETE NO ACTION ON UPDATE CASCADE,
  CONSTRAINT `FK_omoccurrences_tid` FOREIGN KEY (`tidinterpreted`) REFERENCES `taxa` (`TID`) ON DELETE SET NULL ON UPDATE CASCADE,
  CONSTRAINT `FK_omoccurrences_uid` FOREIGN KEY (`observeruid`) REFERENCES `users` (`uid`)
) ENGINE=InnoDB AUTO_INCREMENT=17522 DEFAULT CHARSET=utf8;

 
 */	
	
   // These constants hold the sizes the fields in this table in the database.
   const OCCID_SIZE           = 11; //INTEGER
   const COLLID_SIZE          = 11; //INT
   const DBPK_SIZE            = 45; //45
   const BASISOFRECORD_SIZE   = 32; //32
   const OCCURRENCEID_SIZE    = 255; //255
   const CATALOGNUMBER_SIZE   = 32; //32
   const OTHERCATALOGNUMBERS_SIZE = 255; //255
   const OWNERINSTITUTIONCODE_SIZE = 32; //32
   const INSTITUTIONID_SIZE   = 255; //255
   const COLLECTIONID_SIZE    = 255; //255
   const DATASETID_SIZE       = 255; //255
   const INSTITUTIONCODE_SIZE = 64; //64
   const COLLECTIONCODE_SIZE  = 64; //64
   const FAMILY_SIZE          = 255; //255
   const SCIENTIFICNAME_SIZE  = 255; //255
   const SCINAME_SIZE         = 255; //255
   const TIDINTERPRETED_SIZE  = 11; //INT
   const GENUS_SIZE           = 255; //255
   const SPECIFICEPITHET_SIZE = 255; //255
   const TAXONRANK_SIZE       = 32; //32
   const INFRASPECIFICEPITHET_SIZE = 255; //255
   const SCIENTIFICNAMEAUTHORSHIP_SIZE = 255; //255
   const TAXONREMARKS_SIZE    = 255; //LONGVARCHAR
   const IDENTIFIEDBY_SIZE    = 255; //255
   const DATEIDENTIFIED_SIZE  = 45; //45
   const IDENTIFICATIONREFERENCES_SIZE = 255; //LONGVARCHAR
   const IDENTIFICATIONREMARKS_SIZE = 255; //LONGVARCHAR
   const IDENTIFICATIONQUALIFIER_SIZE = 255; //255
   const TYPESTATUS_SIZE      = 255; //255
   const RECORDEDBY_SIZE      = 255; //255
   const RECORDNUMBER_SIZE    = 45; //45
   const RECORDEDBYID_SIZE    = 255; //255
   const ASSOCIATEDCOLLECTORS_SIZE = 255; //255
   const EVENTDATE_SIZE       = 12; //DATE
   const LATESTDATECOLLECTED_SIZE = 12; //DATE
   const YEAR_SIZE            = 11; //INTEGER
   const MONTH_SIZE           = 11; //INTEGER
   const DAY_SIZE             = 11; //INTEGER
   const STARTDAYOFYEAR_SIZE  = 11; //INTEGER
   const ENDDAYOFYEAR_SIZE    = 11; //INTEGER
   const VERBATIMEVENTDATE_SIZE = 255; //255
   const HABITAT_SIZE         = 255; //LONGVARCHAR
   const SUBSTRATE_SIZE       = 500; //500
   const FIELDNOTES_SIZE      = 255; //LONGVARCHAR
   const FIELDNUMBER_SIZE     = 45; //45
   const EVENTID_SIZE     = 45; //VARCHAR
   const OCCURRENCEREMARKS_SIZE = 255; //LONGVARCHAR
   const INFORMATIONWITHHELD_SIZE = 250; //250
   const DATAGENERALIZATIONS_SIZE = 250; //250
   const ASSOCIATEDOCCURRENCES_SIZE = 255; //LONGVARCHAR
   const ASSOCIATEDTAXA_SIZE  = 255; //LONGVARCHAR
   const DYNAMICPROPERTIES_SIZE = 255; //LONGVARCHAR
   const VERBATIMATTRIBUTES_SIZE = 255; //LONGVARCHAR
   const BEHAVIOR_SIZE = 500; //VARCHAR 
   const REPRODUCTIVECONDITION_SIZE = 255; //255
   const CULTIVATIONSTATUS_SIZE = 11; //INTEGER
   const ESTABLISHMENTMEANS_SIZE = 150; //150
   const LIFESTAGE_SIZE       = 45; //45
   const SEX_SIZE             = 45; //45
   const INDIVIDUALCOUNT_SIZE = 45; //45
   const SAMPLINGPROTOCOL_SIZE = 100; //100
   const PREPARATIONS_SIZE    = 100; //100
   const LOCATIONID_SIZE    = 100; //100
   const WATERBODY_SIZE    = 255; //255
   const COUNTRY_SIZE         = 64; //64
   const STATEPROVINCE_SIZE   = 255; //255
   const COUNTY_SIZE          = 255; //255
   const MUNICIPALITY_SIZE    = 255; //255
   const LOCALITY_SIZE        = 255; //LONGVARCHAR
   const LOCALITYSECURITY_SIZE = 11; //INTEGER
   const LOCALITYSECURITYREASON_SIZE = 100; //100
   const DECIMALLATITUDE_SIZE = 24; //DOUBLE
   const DECIMALLONGITUDE_SIZE = 24; //DOUBLE
   const GEODETICDATUM_SIZE   = 255; //255
   const COORDINATEUNCERTAINTYINMETERS_SIZE = 11; //INTEGER
   const FOOTPRINTWKT_SIZE    = 255; //LONGVARCHAR
   const COORDINATEPRECISION_SIZE = 9; //9,7
   const LOCATIONREMARKS_SIZE = 255; //LONGVARCHAR
   const VERBATIMCOORDINATES_SIZE = 255; //255
   const VERBATIMCOORDINATESYSTEM_SIZE = 255; //255
   const GEOREFERENCEDBY_SIZE = 255; //255
   const GEOREFERENCEPROTOCOL_SIZE = 255; //255
   const GEOREFERENCESOURCES_SIZE = 255; //255
   const GEOREFERENCEVERIFICATIONSTATUS_SIZE = 32; //32
   const GEOREFERENCEREMARKS_SIZE = 255; //255
   const MINIMUMELEVATIONINMETERS_SIZE = 11; //INTEGER
   const MAXIMUMELEVATIONINMETERS_SIZE = 11; //INTEGER
   const VERBATIMELEVATION_SIZE = 255; //255
   const PREVIOUSIDENTIFICATIONS_SIZE = 255; //LONGVARCHAR
   const DISPOSITION_SIZE     = 250; //100
   const GENERICCOLUMN1_SIZE  = 100; //100
   const GENERICCOLUMN2_SIZE  = 100; //100
   const MODIFIED_SIZE        = 21; //TIMESTAMP
   const LANGUAGE_SIZE        = 20; //20
   const OBSERVERUID_SIZE     = 11; //INT
   const PROCESSINGSTATUS_SIZE = 45; //45
   const RECORDENTEREDBY_SIZE = 250; //250
   const DUPLICATEQUANTITY_SIZE = 11; //INTEGER
   const LABELPROJECT_SIZE    = 20; //YEAR
   const DYNAMICFIELDS_SIZE = 250; //LONGVARCHAR
   const DATEENTERED_SIZE= 21; //TIMESTAMP
   const DATELASTMODIFIED_SIZE = 21; //TIMESTAMP
   const MINIMUMDEPTHINMETERS_SIZE = 11; // INTEGER
   const MAXIMUMDEPTHINMETERS_SIZE = 11; // INTEGER
   const VERBATIMDEPTH_SIZE = 50; // varchar 50
   const STORAGELOCATION_SIZE = 100; // varchar 100
    // These constants hold the field names of the table in the database. 
   const OCCID             = 'occid';
   const COLLID            = 'collid';
   const DBPK              = 'dbpk';
   // PreservedSpecimen, LivingSpecimen, HumanObservation
   const BASISOFRECORD     = 'basisOfRecord';
   // UniqueGlobalIdentifier
   const OCCURRENCEID      = 'occurrenceID';
   const CATALOGNUMBER     = 'catalogNumber';
   const OTHERCATALOGNUMBERS = 'otherCatalogNumbers';
   const OWNERINSTITUTIONCODE = 'ownerInstitutionCode';
   const INSTITUTIONID     = 'institutionID';
   const COLLECTIONID      = 'collectionID';
   const DATASETID         = 'datasetID';
   const INSTITUTIONCODE   = 'institutionCode';
   const COLLECTIONCODE    = 'collectionCode';
   const FAMILY            = 'family';
   const SCIENTIFICNAME    = 'scientificName';
   const SCINAME           = 'sciname';
   const TIDINTERPRETED    = 'tidinterpreted';
   const GENUS             = 'genus';
   const SPECIFICEPITHET   = 'specificEpithet';
   const TAXONRANK         = 'taxonRank';
   const INFRASPECIFICEPITHET = 'infraspecificEpithet';
   const SCIENTIFICNAMEAUTHORSHIP = 'scientificNameAuthorship';
   const TAXONREMARKS      = 'taxonRemarks';
   const IDENTIFIEDBY      = 'identifiedBy';
   const DATEIDENTIFIED    = 'dateIdentified';
   const IDENTIFICATIONREFERENCES = 'identificationReferences';
   const IDENTIFICATIONREMARKS = 'identificationRemarks';
   // cf, aff, etc
   const IDENTIFICATIONQUALIFIER = 'identificationQualifier';
   const TYPESTATUS        = 'typeStatus';
   // Collector(s)
   const RECORDEDBY        = 'recordedBy';
   // Collector Number
   const RECORDNUMBER      = 'recordNumber';
   const RECORDEDBYID      = 'recordedById';
   // not DwC
   const ASSOCIATEDCOLLECTORS = 'associatedCollectors';
   const EVENTDATE         = 'eventDate';
   const LATESTDATECOLLECTED = 'latestDateCollected';
   const YEAR              = 'year';
   const MONTH             = 'month';
   const DAY               = 'day';
   const STARTDAYOFYEAR    = 'startDayOfYear';
   const ENDDAYOFYEAR      = 'endDayOfYear';
   const VERBATIMEVENTDATE = 'verbatimEventDate';
   // Habitat, substrait, etc
   const HABITAT           = 'habitat';
   const SUBSTRATE         = 'substrate';
   const FIELDNOTES        = 'fieldNotes';
   const FIELDNUMBER       = 'fieldnumber';
   const EVENTID       = 'eventID';
   // General Notes
   const OCCURRENCEREMARKS = 'occurrenceRemarks';
   const INFORMATIONWITHHELD = 'informationWithheld';
   const DATAGENERALIZATIONS = 'dataGeneralizations';
   const ASSOCIATEDOCCURRENCES = 'associatedOccurrences';
   // Associated Species
   const ASSOCIATEDTAXA    = 'associatedTaxa';
   const DYNAMICPROPERTIES = 'dynamicProperties';
   // Description or organism
   const VERBATIMATTRIBUTES = 'verbatimAttributes';
   // Phenology: flowers, fruit, sterile
   const REPRODUCTIVECONDITION = 'reproductiveCondition';
   // 0 = wild, 1 = cultivated
   const CULTIVATIONSTATUS = 'cultivationStatus';
   // cultivated, invasive, escaped from captivity, wild, native
   const ESTABLISHMENTMEANS = 'establishmentMeans';
   const LIFESTAGE         = 'lifeStage';
   const SEX               = 'sex';
   const INDIVIDUALCOUNT   = 'individualCount';
   const SAMPLINGPROTOCOL  = 'samplingProtocol';
   const SAMPLINGEFFORT    = 'samplingEffort';
   const PREPARATIONS      = 'preparations';
   const LOCATIONID        = 'locationID';
   const WATERBODY         = 'waterBody';
   const COUNTRY           = 'country';
   const STATEPROVINCE     = 'stateProvince';
   const COUNTY            = 'county';
   const MUNICIPALITY      = 'municipality';
   const LOCALITY          = 'locality';
   // 0 = no security; 1 = hidden locality
   const LOCALITYSECURITY  = 'localitySecurity';
   const LOCALITYSECURITYREASON = 'localitySecurityReason';
   const DECIMALLATITUDE   = 'decimalLatitude';
   const DECIMALLONGITUDE  = 'decimalLongitude';
   const GEODETICDATUM     = 'geodeticDatum';
   const COORDINATEUNCERTAINTYINMETERS = 'coordinateUncertaintyInMeters';
   const FOOTPRINTWKT      = 'footprintWKT';
   const COORDINATEPRECISION = 'coordinatePrecision';
   const LOCATIONREMARKS   = 'locationRemarks';
   const VERBATIMCOORDINATES = 'verbatimCoordinates';
   const VERBATIMCOORDINATESYSTEM = 'verbatimCoordinateSystem';
   const GEOREFERENCEDBY   = 'georeferencedBy';
   const GEOREFERENCEPROTOCOL = 'georeferenceProtocol';
   const GEOREFERENCESOURCES = 'georeferenceSources';
   const GEOREFERENCEVERIFICATIONSTATUS = 'georeferenceVerificationStatus';
   const GEOREFERENCEREMARKS = 'georeferenceRemarks';
   const MINIMUMELEVATIONINMETERS = 'minimumElevationInMeters';
   const MAXIMUMELEVATIONINMETERS = 'maximumElevationInMeters';
   const VERBATIMELEVATION = 'verbatimElevation';
   const PREVIOUSIDENTIFICATIONS = 'previousIdentifications';
   const DISPOSITION       = 'disposition';
   const GENERICCOLUMN1    = 'genericcolumn1';
   const GENERICCOLUMN2    = 'genericcolumn2';
   // DateLastModified
   const MODIFIED          = 'modified';
   const LANGUAGE          = 'language';
   const OBSERVERUID       = 'observeruid';
   const PROCESSINGSTATUS  = 'processingstatus';
   const RECORDENTEREDBY   = 'recordEnteredBy';
   const DUPLICATEQUANTITY = 'duplicateQuantity';
   const LABELPROJECT      = 'labelProject';
   const DYNAMICFIELDS     = 'dynamicFields';
   const DATEENTERED      = 'dateEntered';
   const DATELASTMODIFIED  = 'dateLastModified';
   const MINIMUMDEPTHINMETERS = 'minimumDepthInMeters';
   const MAXIMUMDEPTHINMETER = 'SmaximumDepthInMeters';
   const VERBATIMDEPTH = 'verbatimDepth';
   const STORAGELOCATION = 'storageLocation';

   //---------------------------------------------------------------------------

   // interface tableSchema implementation
   // schemaPK returns array of primary key field names
   public function schemaPK() {
       return $this->primaryKeyArray;
   } 
   // schemaHaveDistinct returns array of field names for which selectDistinct{fieldname} methods are available.
   public function schemaHaveDistinct() {
       return $this->selectDistinctFieldsArray;
   } 
   // schemaFields returns array of all field names
   public function schemaFields() { 
       return $this->allFieldsArray;
   } 
/*  Example sanitized retrieval of variable matching object variables from $_GET 
/*  Customize these to limit each variable to narrowest possible set of known good values. 

  $occid = substr(preg_replace('/[^0-9\-\[NULL\]]/','',$_GET['occid']), 0, 11);
  $collid = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['collid']), 0, 11);
  $dbpk = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['dbpk']), 0, 45);
  $basisOfRecord = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['basisOfRecord']), 0, 32);
  $occurrenceID = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['occurrenceID']), 0, 255);
  $catalogNumber = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['catalogNumber']), 0, 32);
  $otherCatalogNumbers = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['otherCatalogNumbers']), 0, 255);
  $ownerInstitutionCode = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['ownerInstitutionCode']), 0, 32);
  $institutionID = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['institutionID']), 0, 255);
  $collectionID = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['collectionID']), 0, 255);
  $datasetID = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['datasetID']), 0, 255);
  $institutionCode = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['institutionCode']), 0, 64);
  $collectionCode = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['collectionCode']), 0, 64);
  $family = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['family']), 0, 255);
  $scientificName = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['scientificName']), 0, 255);
  $sciname = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['sciname']), 0, 255);
  $tidinterpreted = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['tidinterpreted']), 0, 11);
  $genus = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['genus']), 0, 255);
  $specificEpithet = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['specificEpithet']), 0, 255);
  $taxonRank = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['taxonRank']), 0, 32);
  $infraspecificEpithet = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['infraspecificEpithet']), 0, 255);
  $scientificNameAuthorship = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['scientificNameAuthorship']), 0, 255);
  $taxonRemarks = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['taxonRemarks']), 0, 255);
  $identifiedBy = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['identifiedBy']), 0, 255);
  $dateIdentified = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['dateIdentified']), 0, 45);
  $identificationReferences = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['identificationReferences']), 0, 255);
  $identificationRemarks = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['identificationRemarks']), 0, 255);
  $identificationQualifier = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['identificationQualifier']), 0, 255);
  $typeStatus = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['typeStatus']), 0, 255);
  $recordedBy = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['recordedBy']), 0, 255);
  $recordNumber = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['recordNumber']), 0, 45);
  $recordedById = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['recordedById']), 0, 255);
  $associatedCollectors = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['associatedCollectors']), 0, 255);
  $eventDate = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['eventDate']), 0, 12);
  $latestDateCollected = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['latestDateCollected']), 0, 12);
  $year = substr(preg_replace('/[^0-9\-\[NULL\]]/','',$_GET['year']), 0, 11);
  $month = substr(preg_replace('/[^0-9\-\[NULL\]]/','',$_GET['month']), 0, 11);
  $day = substr(preg_replace('/[^0-9\-\[NULL\]]/','',$_GET['day']), 0, 11);
  $startDayOfYear = substr(preg_replace('/[^0-9\-\[NULL\]]/','',$_GET['startDayOfYear']), 0, 11);
  $endDayOfYear = substr(preg_replace('/[^0-9\-\[NULL\]]/','',$_GET['endDayOfYear']), 0, 11);
  $verbatimEventDate = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['verbatimEventDate']), 0, 255);
  $habitat = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['habitat']), 0, 255);
  $substrate = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['substrate']), 0, 500);
  $fieldNotes = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['fieldNotes']), 0, 255);
  $fieldnumber = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['fieldnumber']), 0, 45);
  $eventID = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['eventID']), 0, 45);
  $occurrenceRemarks = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['occurrenceRemarks']), 0, 255);
  $informationWithheld = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['informationWithheld']), 0, 250);
  $dataGeneralizations = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['dataGeneralizations']), 0, 250);
  $associatedOccurrences = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['associatedOccurrences']), 0, 255);
  $associatedTaxa = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['associatedTaxa']), 0, 255);
  $dynamicProperties = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['dynamicProperties']), 0, 255);
  $verbatimAttributes = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['verbatimAttributes']), 0, 255);
  $behavior = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['behavior']), 0, 255);
  $reproductiveCondition = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['reproductiveCondition']), 0, 255);
  $cultivationStatus = substr(preg_replace('/[^0-9\-\[NULL\]]/','',$_GET['cultivationStatus']), 0, 11);
  $establishmentMeans = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['establishmentMeans']), 0, 150);
  $lifeStage = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['lifeStage']), 0, 45);
  $sex = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['sex']), 0, 45);
  $individualCount = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['individualCount']), 0, 45);
  $samplingProtocol = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['samplingProtocol']), 0, 100);
  $samplingEffort = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['samplingEffort']), 0, 200);
  $preparations = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['preparations']), 0, 100);
  $locationID = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['locationID']), 0, 100);
  $waterBody = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['waterBody']), 0, 255);
  $country = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['country']), 0, 64);
  $stateProvince = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['stateProvince']), 0, 255);
  $county = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['county']), 0, 255);
  $municipality = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['municipality']), 0, 255);
  $locality = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['locality']), 0, 255);
  $localitySecurity = substr(preg_replace('/[^0-9\-\[NULL\]]/','',$_GET['localitySecurity']), 0, 11);
  $localitySecurityReason = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['localitySecurityReason']), 0, 100);
  $decimalLatitude = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['decimalLatitude']), 0, 24);
  $decimalLongitude = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['decimalLongitude']), 0, 24);
  $geodeticDatum = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['geodeticDatum']), 0, 255);
  $coordinateUncertaintyInMeters = substr(preg_replace('/[^0-9\-\[NULL\]]/','',$_GET['coordinateUncertaintyInMeters']), 0, 11);
  $footprintWKT = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['footprintWKT']), 0, 255);
  $coordinatePrecision = substr(preg_replace('/[^0-9\-\.\[NULL\]]/','',$_GET['coordinatePrecision']), 0, 9);
  $locationRemarks = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['locationRemarks']), 0, 255);
  $verbatimCoordinates = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['verbatimCoordinates']), 0, 255);
  $verbatimCoordinateSystem = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['verbatimCoordinateSystem']), 0, 255);
  $georeferencedBy = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['georeferencedBy']), 0, 255);
  $georeferenceProtocol = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['georeferenceProtocol']), 0, 255);
  $georeferenceSources = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['georeferenceSources']), 0, 255);
  $georeferenceVerificationStatus = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['georeferenceVerificationStatus']), 0, 32);
  $georeferenceRemarks = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['georeferenceRemarks']), 0, 255);
  $minimumElevationInMeters = substr(preg_replace('/[^0-9\-\[NULL\]]/','',$_GET['minimumElevationInMeters']), 0, 11);
  $maximumElevationInMeters = substr(preg_replace('/[^0-9\-\[NULL\]]/','',$_GET['maximumElevationInMeters']), 0, 11);
  $verbatimElevation = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['verbatimElevation']), 0, 255);
  $previousIdentifications = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['previousIdentifications']), 0, 255);
  $disposition = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['disposition']), 0, 250);
  $genericcolumn1 = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['genericcolumn1']), 0, 100);
  $genericcolumn2 = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['genericcolumn2']), 0, 100);
  $modified = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['modified']), 0, 21);
  $language = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['language']), 0, 20);
  $observeruid = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['observeruid']), 0, 11);
  $processingstatus = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['processingstatus']), 0, 45);
  $recordEnteredBy = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['recordEnteredBy']), 0, 250);
  $duplicateQuantity = substr(preg_replace('/[^0-9\-\[NULL\]]/','',$_GET['duplicateQuantity']), 0, 11);
  $labelProject = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['labelProject']), 0, 20);
  $dynamicFields = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['dynamicFields']), 0, 20);
  $dateLastModified = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['dateLastModified']), 0, 21);
*/

   //---------------------------------------------------------------------------

   private $occid; // PK INTEGER 
   private $collid; // INT 
   private $dbpk; // VARCHAR(150) 
   private $basisOfRecord = "PreservedSpecimen"; // VARCHAR(32) PreservedSpecimen, LivingSpecimen, HumanObservation
   private $occurrenceID; // VARCHAR(255) UniqueGlobalIdentifier
   private $catalogNumber; // VARCHAR(32) 
   private $otherCatalogNumbers; // VARCHAR(255) 
   private $ownerInstitutionCode; // VARCHAR(32) 
   private $institutionID; // VARCHAR(255) 
   private $collectionID; // VARCHAR(255) 
   private $datasetID; // VARCHAR(255) 
   private $institutionCode; // VARCHAR(64) 
   private $collectionCode; // VARCHAR(64) 
   private $family; // VARCHAR(255) 
   private $scientificName; // VARCHAR(255) 
   private $sciname; // VARCHAR(255) 
   private $tidinterpreted; // INT 
   private $genus; // VARCHAR(255) 
   private $specificEpithet; // VARCHAR(255) 
   private $taxonRank; // VARCHAR(32) 
   private $infraspecificEpithet; // VARCHAR(255) 
   private $scientificNameAuthorship; // VARCHAR(255) 
   private $taxonRemarks; // LONGVARCHAR 
   private $identifiedBy; // VARCHAR(255) 
   private $dateIdentified; // VARCHAR(45) 
   private $identificationReferences; // LONGVARCHAR 
   private $identificationRemarks; // LONGVARCHAR 
   private $identificationQualifier; // VARCHAR(255) cf, aff, etc
   private $typeStatus; // VARCHAR(255) 
   private $recordedBy; // VARCHAR(255) Collector(s)
   private $recordNumber; // VARCHAR(45) Collector Number
   private $recordedById; // VARCHAR(255) 
   private $associatedCollectors; // VARCHAR(255) not DwC
   private $eventDate; // DATE 
   private $latestDateCollected; // DATE 
   private $year; // INTEGER 
   private $month; // INTEGER 
   private $day; // INTEGER 
   private $startDayOfYear; // INTEGER 
   private $endDayOfYear; // INTEGER 
   private $verbatimEventDate; // VARCHAR(255) 
   private $habitat; // LONGVARCHAR Habitat, substrait, etc
   private $substrate; // VARCHAR(500) 
   private $fieldNotes; // LONGVARCHAR 
   private $fieldnumber; // VARCHAR(45)
   private $eventID; // VARCHAR(45)
   private $occurrenceRemarks; // LONGVARCHAR General Notes
   private $informationWithheld; // VARCHAR(250) 
   private $dataGeneralizations; // VARCHAR(250) 
   private $associatedOccurrences; // LONGVARCHAR 
   private $associatedTaxa; // LONGVARCHAR Associated Species
   private $dynamicProperties; // LONGVARCHAR 
   private $verbatimAttributes; // LONGVARCHAR  description of organism 
   private $behavior; // VARCHAR
   private $reproductiveCondition; // VARCHAR(255) Phenology: flowers, fruit, sterile
   private $cultivationStatus; // INTEGER 0 = wild, 1 = cultivated
   private $establishmentMeans; // VARCHAR(150) cultivated, invasive, escaped from captivity, wild, native
   private $lifeStage; // VARCHAR(45) 
   private $sex; // VARCHAR(45) 
   private $individualCount; // VARCHAR(45) 
   private $samplingProtocol; // VARCHAR(100) 
   private $samplingEffort; // VARCHAR(200) 
   private $preparations; // VARCHAR(100) 
   private $waterBody; // varchar(255)
   private $locationID; // VARCHAR(100)
   private $country; // VARCHAR(64) 
   private $stateProvince; // VARCHAR(255) 
   private $county; // VARCHAR(255) 
   private $municipality; // VARCHAR(255) 
   private $locality; // LONGVARCHAR 
   private $localitySecurity; // INTEGER 0 = no security; 1 = hidden locality
   private $localitySecurityReason; // VARCHAR(100) 
   private $decimalLatitude; // DOUBLE 
   private $decimalLongitude; // DOUBLE 
   private $geodeticDatum; // VARCHAR(255) 
   private $coordinateUncertaintyInMeters; // INTEGER 
   private $footprintWKT; // LONGVARCHAR 
   private $coordinatePrecision; // DECIMAL(9,7) 
   private $locationRemarks; // LONGVARCHAR 
   private $verbatimCoordinates; // VARCHAR(255) 
   private $verbatimCoordinateSystem; // VARCHAR(255) 
   private $georeferencedBy; // VARCHAR(255) 
   private $georeferenceProtocol; // VARCHAR(255) 
   private $georeferenceSources; // VARCHAR(255) 
   private $georeferenceVerificationStatus; // VARCHAR(32) 
   private $georeferenceRemarks; // VARCHAR(255) 
   private $minimumElevationInMeters; // INTEGER 
   private $maximumElevationInMeters; // INTEGER 
   private $verbatimElevation; // VARCHAR(255) 
   private $previousIdentifications; // LONGVARCHAR 
   private $disposition; // VARCHAR(250) 
   private $genericcolumn1; // VARCHAR(100) 
   private $genericcolumn2; // VARCHAR(100) 
   private $modified; // TIMESTAMP DateLastModified
   private $language; // VARCHAR(20) 
   private $observeruid; // INT 
   private $processingstatus; // VARCHAR(45) 
   private $recordEnteredBy; // VARCHAR(250) 
   private $duplicateQuantity; // INTEGER 
   private $labelProject; // YEAR 
   private $dynamicFields; // TEXT 
   private $dateEntered; // TIMESTAMP 
   private $dateLastModified; // TIMESTAMP 

   private $minimumDepthInMeters;
   private $maximumDepthInMeters;
   private $verbatimDepth;
   private $storageLocation;

   // No implementation in Symbiota
   public $dateSerialized;
   public $serializedBy;
   public $collectorid; 
   public $documentGuid;
   public $documentDate;
   public $fundingSource;
   private $taxonGuid;

   // supporting fields
   private $dirty;
   private $loaded;
   private $error;
   const FIELDLIST = ' occid, collid, dbpk, basisOfRecord, occurrenceID, catalogNumber, otherCatalogNumbers, ownerInstitutionCode, institutionID, collectionID, datasetID, institutionCode, collectionCode, family, scientificName, sciname, tidinterpreted, genus, specificEpithet, taxonRank, infraspecificEpithet, scientificNameAuthorship, taxonRemarks, identifiedBy, dateIdentified, identificationReferences, identificationRemarks, identificationQualifier, typeStatus, recordedBy, recordNumber, recordedById, associatedCollectors, eventDate, latestDateCollected, year, month, day, startDayOfYear, endDayOfYear, verbatimEventDate, habitat, substrate, fieldNotes, fieldnumber, eventID, occurrenceRemarks, informationWithheld, dataGeneralizations, associatedOccurrences, associatedTaxa, dynamicProperties, verbatimAttributes, behavior, reproductiveCondition, cultivationStatus, establishmentMeans, lifeStage, sex, individualCount, samplingProtocol, samplingEffort, preparations, waterBody,locationID, country, stateProvince, county, municipality, locality, localitySecurity, localitySecurityReason, decimalLatitude, decimalLongitude, geodeticDatum, coordinateUncertaintyInMeters, footprintWKT, coordinatePrecision, locationRemarks, verbatimCoordinates, verbatimCoordinateSystem, georeferencedBy, georeferenceProtocol, georeferenceSources, georeferenceVerificationStatus, georeferenceRemarks, minimumElevationInMeters, maximumElevationInMeters, verbatimElevation, previousIdentifications, disposition, genericcolumn1, genericcolumn2, modified, language, observeruid, processingstatus, recordEnteredBy, duplicateQuantity, labelProject, dynamicFields, dateEntered, dateLastModified, minimumDepthInMeters, maximumDepthInMeters, verbatimDepth, storageLocation ';
   const PKFIELDLIST = ' occid, ';
   const NUMBER_OF_PRIMARY_KEYS = 1;
   private $primaryKeyArray = array( 1 => 'occid'  ) ;
   private $allFieldsArray = array( 0 => 'occid' , 1 => 'collid' , 2 => 'dbpk' , 3 => 'basisOfRecord' , 4 => 'occurrenceID' , 5 => 'catalogNumber' , 6 => 'otherCatalogNumbers' , 7 => 'ownerInstitutionCode' , 8 => 'institutionID' , 9 => 'collectionID' , 10 => 'datasetID' , 11 => 'institutionCode' , 12 => 'collectionCode' , 13 => 'family' , 14 => 'scientificName' , 15 => 'sciname' , 16 => 'tidinterpreted' , 17 => 'genus' , 18 => 'specificEpithet' , 19 => 'taxonRank' , 20 => 'infraspecificEpithet' , 21 => 'scientificNameAuthorship' , 22 => 'taxonRemarks' , 23 => 'identifiedBy' , 24 => 'dateIdentified' , 25 => 'identificationReferences' , 26 => 'identificationRemarks' , 27 => 'identificationQualifier' , 28 => 'typeStatus' , 29 => 'recordedBy' , 30 => 'recordNumber' , 31 => 'recordedById' , 32 => 'associatedCollectors' , 33 => 'eventDate' , 106 => 'latestDateCollected' , 34 => 'year' , 35 => 'month' , 36 => 'day' , 37 => 'startDayOfYear' , 38 => 'endDayOfYear' , 39 => 'verbatimEventDate' , 40 => 'habitat' , 41 => 'substrate' , 42 => 'fieldNotes' , 43 => 'fieldnumber' , 105 => 'eventID' , 44 => 'occurrenceRemarks' , 45 => 'informationWithheld' , 46 => 'dataGeneralizations' , 47 => 'associatedOccurrences' , 48 => 'associatedTaxa' , 49 => 'dynamicProperties' , 50 => 'verbatimAttributes' , 51 => 'behavior' , 52 => 'reproductiveCondition' , 53 => 'cultivationStatus' , 54 => 'establishmentMeans' , 55 => 'lifeStage' , 56 => 'sex' , 57 => 'individualCount' , 58 => 'samplingProtocol' , 101 => 'samplingEffort' , 59 => 'preparations' , 103 => 'waterBody' , 104 => 'locationID' , 60 => 'country' , 61 => 'stateProvince' , 62 => 'county' , 63 => 'municipality' , 64 => 'locality' , 65 => 'localitySecurity' , 66 => 'localitySecurityReason' , 67 => 'decimalLatitude' , 68 => 'decimalLongitude' , 69 => 'geodeticDatum' , 70 => 'coordinateUncertaintyInMeters' , 71 => 'footprintWKT' , 72 => 'coordinatePrecision' , 73 => 'locationRemarks' , 74 => 'verbatimCoordinates' , 75 => 'verbatimCoordinateSystem' , 76 => 'georeferencedBy' , 77 => 'georeferenceProtocol' , 78 => 'georeferenceSources' , 79 => 'georeferenceVerificationStatus' , 80 => 'georeferenceRemarks' , 81 => 'minimumElevationInMeters' , 82 => 'maximumElevationInMeters' , 83 => 'verbatimElevation' , 84 => 'previousIdentifications' , 85 => 'disposition' , 86 => 'genericcolumn1' , 87 => 'genericcolumn2' , 88 => 'modified' , 89 => 'language' , 91 => 'observeruid' , 92 => 'processingstatus' , 93 => 'recordEnteredBy' , 94 => 'duplicateQuantity' , 95 => 'labelProject' , 107 => 'dynamicFields' , 102 =>'dateEntered' , 96 => 'dateLastModified', 97 => 'minimumDepthInMeters', 98 => 'maximumDepthInMeters', 99 => 'verbatimDepth', 100 => 'storageLocation' ) ;
   private $selectDistinctFieldsArray = array( 1 => 'collid' , 2 => 'dbpk' , 4 => 'occurrenceID' , 5 => 'catalogNumber' , 7 => 'ownerInstitutionCode' , 13 => 'family' , 15 => 'sciname' , 16 => 'tidinterpreted' , 29 => 'recordedBy' , 30 => 'recordNumber' , 31 => 'recordedById' , 33 => 'eventDate' , 60 => 'country' , 61 => 'stateProvince' , 62 => 'county' , 63 => 'municipality' , 91 => 'observeruid' , 92 => 'processingstatus'  ) ;

   //---------------------------------------------------------------------------

   // constructor 
   function __construct(){
       $this->occid = NULL;
       $this->collid = NULL;
       $this->dbpk = NULL;
       $this->basisOfRecord = NULL;
       $this->occurrenceID = NULL;
       $this->catalogNumber = NULL;
       $this->otherCatalogNumbers = NULL;
       $this->ownerInstitutionCode = NULL;
       $this->institutionID = NULL;
       $this->collectionID = NULL;
       $this->datasetID = NULL;
       $this->institutionCode = NULL;
       $this->collectionCode = NULL;
       $this->family = NULL;
       $this->scientificName = NULL;
       $this->sciname = NULL;
       $this->tidinterpreted = NULL;
       $this->genus = NULL;
       $this->specificEpithet = NULL;
       $this->taxonRank = NULL;
       $this->infraspecificEpithet = NULL;
       $this->scientificNameAuthorship = NULL;
       $this->taxonRemarks = NULL;
       $this->identifiedBy = NULL;
       $this->dateIdentified = NULL;
       $this->identificationReferences = NULL;
       $this->identificationRemarks = NULL;
       $this->identificationQualifier = NULL;
       $this->typeStatus = NULL;
       $this->recordedBy = NULL;
       $this->recordNumber = NULL;
       $this->recordedById = NULL;
       $this->associatedCollectors = NULL;
       $this->eventDate = NULL;
       $this->latestDateCollected = NULL;
       $this->year = NULL;
       $this->month = NULL;
       $this->day = NULL;
       $this->startDayOfYear = NULL;
       $this->endDayOfYear = NULL;
       $this->verbatimEventDate = NULL;
       $this->habitat = NULL;
       $this->substrate = NULL;
       $this->fieldNotes = NULL;
       $this->eventID = NULL;
       $this->occurrenceRemarks = NULL;
       $this->informationWithheld = NULL;
       $this->dataGeneralizations = NULL;
       $this->associatedOccurrences = NULL;
       $this->associatedTaxa = NULL;
       $this->dynamicProperties = NULL;
       $this->verbatimAttributes = NULL;
       $this->behavior = NULL;
       $this->reproductiveCondition = NULL;
       $this->cultivationStatus = NULL;
       $this->establishmentMeans = NULL;
       $this->lifeStage = NULL;
       $this->sex = NULL;
       $this->individualCount = NULL;
       $this->samplingProtocol = NULL;
       $this->samplingEffort = NULL;
       $this->locationID = NULL;
       $this->waterBody = NULL;
       $this->country = NULL;
       $this->stateProvince = NULL;
       $this->county = NULL;
       $this->municipality = NULL;
       $this->locality = NULL;
       $this->localitySecurity = 0;
       $this->localitySecurityReason = NULL;
       $this->decimalLatitude = NULL;
       $this->decimalLongitude = NULL;
       $this->geodeticDatum = NULL;
       $this->coordinateUncertaintyInMeters = NULL;
       $this->coordinatePrecision = NULL;
       $this->locationRemarks = NULL;
       $this->verbatimCoordinates = NULL;
       $this->verbatimCoordinateSystem = NULL;
       $this->georeferencedBy = NULL;
       $this->georeferenceProtocol = NULL;
       $this->georeferenceSources = NULL;
       $this->georeferenceVerificationStatus = NULL;
       $this->georeferenceRemarks = NULL;
       $this->minimumElevationInMeters = NULL;
       $this->maximumElevationInMeters = NULL;
       $this->verbatimElevation = NULL;
       $this->previousIdentifications = NULL;
       $this->disposition = NULL;
       $this->modified = NULL;
       $this->language = NULL;
       $this->observeruid = NULL;
       $this->processingstatus = NULL;
       $this->recordEnteredBy = NULL;
       $this->duplicateQuantity = NULL;
       $this->labelProject = NULL;
       $this->dynamicFields = NULL;
       $this->dateEntered = NULL;
       $this->dateLastModified = NULL;
       $this->minimumDepthInMeters = NULL;
       $this->maximumDepthInMeters = NULL;
       $this->verbatimDepth = NULL;
       $this->storageLocation = NULL;
       $this->dirty = false;
       $this->loaded = false;
       $this->error = '';
   }

   private function l_addslashes($value) {
      $retval = $value;
      if (!get_magic_quotes_gpc()) {
          $retval = addslashes($value);
      }
      return $retval;
   }
   private function l_stripslashes($value) {
      $retval = $value;
      if (!get_magic_quotes_gpc()) {
          $retval = stripslashes($value);
      }
      return $retval;
   }
   public function isDirty() {
       return $this->dirty;
   }
   public function isLoaded() {
       return $this->loaded;
   }
   public function errorMessage() {
       return $this->error;
   }

   //----------------------- Supporting Functions ------------------------------

   public function loadByDWCTriplet($institutionCode, $collectionCode, $catalogNumber) {
    // ******* Note: $connection must be a mysqli object.
    global $connection;
    $returnvalue = false;
    $this->occid = null;
    if($institutionCode != NULL && $collectionCode !=NULL && $catalogNumber!=NULL) {
        $preparesql = 'SELECT occid, collid, dbpk, basisOfRecord, occurrenceID, catalogNumber, otherCatalogNumbers, ownerInstitutionCode, 
        institutionID, collectionID, datasetID, institutionCode, collectionCode, family, scientificName, sciname, tidinterpreted, genus, 
        specificEpithet, taxonRank, infraspecificEpithet, scientificNameAuthorship, taxonRemarks, identifiedBy, dateIdentified, identificationReferences, 
        identificationRemarks, identificationQualifier, typeStatus, recordedBy, recordNumber, recordedById, associatedCollectors, 
        eventDate, latestDateCollected, year, month, day, startDayOfYear, endDayOfYear, verbatimEventDate, habitat, substrate, fieldNotes, fieldnumber, eventID, 
        occurrenceRemarks, informationWithheld, dataGeneralizations, associatedOccurrences, associatedTaxa, dynamicProperties, verbatimAttributes, 
        behavior, reproductiveCondition, cultivationStatus, establishmentMeans, lifeStage, sex, individualCount, samplingProtocol, samplingEffort, 
        preparations, waterBody, locationID, country, stateProvince, county, municipality, locality, localitySecurity, localitySecurityReason, decimalLatitude, 
        decimalLongitude, geodeticDatum, coordinateUncertaintyInMeters, footprintWKT, coordinatePrecision, locationRemarks, verbatimCoordinates, 
        verbatimCoordinateSystem, georeferencedBy, georeferenceProtocol, georeferenceSources, georeferenceVerificationStatus, georeferenceRemarks, 
        minimumElevationInMeters, maximumElevationInMeters, verbatimElevation, previousIdentifications, disposition, genericcolumn1, genericcolumn2, 
        modified, language, observeruid, processingstatus, recordEnteredBy, duplicateQuantity, labelProject, dynamicFields, dateEntered, dateLastModified, 
        minimumDepthInMeters, maximumDepthInMeters, verbatimDepth, storageLocation
        FROM omoccurrences WHERE institutionCode = ? and collectionCode = ? and catalogNumber = ?';
        
        if ($statement = $connection->prepare($preparesql)) {
            $statement->bind_param("sss", $institutionCode, $collectionCode, $catalogNumber);
            $statement->execute();
            $statement->bind_result($this->occid, $this->collid, $this->dbpk, $this->basisOfRecord, $this->occurrenceID, $this->catalogNumber, $this->otherCatalogNumbers, $this->ownerInstitutionCode, $this->institutionID, $this->collectionID, $this->datasetID, $this->institutionCode, $this->collectionCode, $this->family, $this->scientificName, $this->sciname, $this->tidinterpreted, $this->genus, $this->specificEpithet, $this->taxonRank, $this->infraspecificEpithet, $this->scientificNameAuthorship, $this->taxonRemarks, $this->identifiedBy, $this->dateIdentified, $this->identificationReferences, $this->identificationRemarks, $this->identificationQualifier, $this->typeStatus, $this->recordedBy, $this->recordNumber, $this->recordedById, $this->associatedCollectors, $this->eventDate, $this->latestDateCollected, $this->year, $this->month, $this->day, $this->startDayOfYear, $this->endDayOfYear, $this->verbatimEventDate, $this->habitat, $this->substrate, $this->fieldNotes, $this->fieldnumber, $this->eventID, $this->occurrenceRemarks, $this->informationWithheld, $this->dataGeneralizations, $this->associatedOccurrences, $this->associatedTaxa, $this->dynamicProperties, $this->verbatimAttributes, $this->behavior, $this->reproductiveCondition, $this->cultivationStatus, $this->establishmentMeans, $this->lifeStage, $this->sex, $this->individualCount, $this->samplingProtocol, $this->samplingEffort, $this->preparations, $this->waterBody, $this->locationID, $this->country, $this->stateProvince, $this->county, $this->municipality, $this->locality, $this->localitySecurity, $this->localitySecurityReason, $this->decimalLatitude, $this->decimalLongitude, $this->geodeticDatum, $this->coordinateUncertaintyInMeters, $this->footprintWKT, $this->coordinatePrecision, $this->locationRemarks, $this->verbatimCoordinates, $this->verbatimCoordinateSystem, $this->georeferencedBy, $this->georeferenceProtocol, $this->georeferenceSources, $this->georeferenceVerificationStatus, $this->georeferenceRemarks, $this->minimumElevationInMeters, $this->maximumElevationInMeters, $this->verbatimElevation, $this->previousIdentifications, $this->disposition, $this->genericcolumn1, $this->genericcolumn2, $this->modified, $this->language, $this->observeruid, $this->processingstatus, $this->recordEnteredBy, $this->duplicateQuantity, $this->labelProject, $this->dynamicFields, $this->dateEntered, $this->dateLastModified, $this->minimumDepthInMeters, $this->maximumDepthInMeters, $this->verbatimDepth, $this->storageLocation);
            $statement->fetch();
            if ($this->occid!=null) { 
                $returnvalue = true;
                $this->loaded = true;
                $this->dirty = false;
            }
            $statement->close();
        }
   
    }
    return $returnvalue;
   } 

   public function loadByCollidCatalog($collid, $catalogNumber) {
    // ******* Note: $connection must be a mysqli object.
    global $connection;
    $returnvalue = false;
    $this->occid = null;
    if($collid !=NULL && $catalogNumber!=NULL) {
        $preparesql = 'SELECT occid, collid, dbpk, basisOfRecord, occurrenceID, catalogNumber, otherCatalogNumbers, ownerInstitutionCode, institutionID, collectionID, datasetID, institutionCode, collectionCode, family, scientificName, sciname, tidinterpreted, genus, specificEpithet, taxonRank, infraspecificEpithet, scientificNameAuthorship, taxonRemarks, identifiedBy, dateIdentified, identificationReferences, identificationRemarks, identificationQualifier, typeStatus, recordedBy, recordNumber, recordedById, associatedCollectors, eventDate, latestDateCollected, year, month, day, startDayOfYear, endDayOfYear, verbatimEventDate, habitat, substrate, fieldNotes, fieldnumber, eventID, occurrenceRemarks, informationWithheld, dataGeneralizations, associatedOccurrences, associatedTaxa, dynamicProperties, verbatimAttributes, behavior, reproductiveCondition, cultivationStatus, establishmentMeans, lifeStage, sex, individualCount, samplingProtocol, samplingEffort, preparations, waterBody, locationID, country, stateProvince, county, municipality, locality, localitySecurity, localitySecurityReason, decimalLatitude, decimalLongitude, geodeticDatum, coordinateUncertaintyInMeters, footprintWKT, coordinatePrecision, locationRemarks, verbatimCoordinates, verbatimCoordinateSystem, georeferencedBy, georeferenceProtocol, georeferenceSources, georeferenceVerificationStatus, georeferenceRemarks, minimumElevationInMeters, maximumElevationInMeters, verbatimElevation, previousIdentifications, disposition, genericcolumn1, genericcolumn2, modified, language, observeruid, processingstatus, recordEnteredBy, duplicateQuantity, labelProject, dynamicFields, dateEntered, dateLastModified, minimumDepthInMeters, maximumDepthInMeters, verbatimDepth, storageLocation FROM omoccurrences WHERE collid = ? and catalogNumber = ?';
        if ($statement = $connection->prepare($preparesql)) {
            $statement->bind_param("ss", $collid, $catalogNumber);
            $statement->execute();
            $statement->bind_result($this->occid, $this->collid, $this->dbpk, $this->basisOfRecord, $this->occurrenceID, $this->catalogNumber, $this->otherCatalogNumbers, $this->ownerInstitutionCode, $this->institutionID, $this->collectionID, $this->datasetID, $this->institutionCode, $this->collectionCode, $this->family, $this->scientificName, $this->sciname, $this->tidinterpreted, $this->genus, $this->specificEpithet, $this->taxonRank, $this->infraspecificEpithet, $this->scientificNameAuthorship, $this->taxonRemarks, $this->identifiedBy, $this->dateIdentified, $this->identificationReferences, $this->identificationRemarks, $this->identificationQualifier, $this->typeStatus, $this->recordedBy, $this->recordNumber, $this->recordedById, $this->associatedCollectors, $this->eventDate, $this->latestDateCollected, $this->year, $this->month, $this->day, $this->startDayOfYear, $this->endDayOfYear, $this->verbatimEventDate, $this->habitat, $this->substrate, $this->fieldNotes, $this->fieldnumber, $this->eventID, $this->occurrenceRemarks, $this->informationWithheld, $this->dataGeneralizations, $this->associatedOccurrences, $this->associatedTaxa, $this->dynamicProperties, $this->verbatimAttributes, $this->behavior, $this->reproductiveCondition, $this->cultivationStatus, $this->establishmentMeans, $this->lifeStage, $this->sex, $this->individualCount, $this->samplingProtocol, $this->samplingEffort, $this->preparations, $this->locationID, $this->waterBody, $this->country, $this->stateProvince, $this->county, $this->municipality, $this->locality, $this->localitySecurity, $this->localitySecurityReason, $this->decimalLatitude, $this->decimalLongitude, $this->geodeticDatum, $this->coordinateUncertaintyInMeters, $this->footprintWKT, $this->coordinatePrecision, $this->locationRemarks, $this->verbatimCoordinates, $this->verbatimCoordinateSystem, $this->georeferencedBy, $this->georeferenceProtocol, $this->georeferenceSources, $this->georeferenceVerificationStatus, $this->georeferenceRemarks, $this->minimumElevationInMeters, $this->maximumElevationInMeters, $this->verbatimElevation, $this->previousIdentifications, $this->disposition, $this->genericcolumn1, $this->genericcolumn2, $this->modified, $this->language, $this->observeruid, $this->processingstatus, $this->recordEnteredBy, $this->duplicateQuantity, $this->labelProject, $this->dynamicFields, $this->dateEntered, $this->dateLastModified, $this->minimumDepthInMeters, $this->maximumDepthInMeters, $this->verbatimDepth, $this->storageLocation);
            $statement->fetch();
            if ($this->occid!=null) {
                $returnvalue = true;
            }
            $statement->close();
        }
         
        $this->loaded = true;
        $this->dirty = false;
    }
    return $returnvalue;
   }   
   
   /**
    * Lookup the symbiota collid for a collection given an institution code and
    * collection code, or just a collection code.  
    *
    * If given null for an insitution code, will search on collection code and
    * return the first matching collection code, trying first 
    * omcollections.collectionCode, then omcollections.institutionCode, then 
    * looking for omoccurrences.collectionCode.  These cover likely cases  
    * where Symbiota instances that manage botanical information and follow or 
    * do not follow the apple core guidance in omcollections, where the 
    * collection code is the index herbariorum code for the herbarium.  This 
    * is probably not reasonable for non-botanical Symbiota instances, but 
    * rows in Symbiota omcollections are likely to represent institutions 
    * rather than collections, so the desired behavior will only be seen if   
    * both insitution code and collection code are be provided to this
    * function and are correctly represented in omcollections.
    *
    * @param insititutionCode null or the dwc:institutionCode for the collection
    * @param collectionCode the dwc:collectionCode for the collection.
    */
   public static function lookupCollid($institutionCode, $collectionCode) {
       // ******* Note: $connection must be a mysqli object.
       global $connection;
       $returnvalue = null;
       if ($institutionCode==null || strlen($institutionCode)==0) { 
           if($collectionCode != NULL) {
           	   // if only collection code is supplied, try several possible mappings for 
               // the collection code (in omcollections as collection code, in omcollections
               // as institution code (plausible for zoological collections or botanical 
               // collections where AppleCore is not being followed), or in omoccurrences 
               // (where one omcollection record is at the institution level and omoccurrences
               // records contain several different collectioncodes for one collid)).
           	   $found = false;
               $sql = 'select collid from omcollections where collectioncode = ? ';
               if ($statement = $connection->prepare($sql)) {
                   $statement->bind_param("s", $collectionCode);
                   $statement->execute();
                   $statement->bind_result($returnvalue);
                   $statement->store_result();
                   $statement->fetch();
               	   if ($statement->num_rows == 1) { $found = true; }
                   $statement->close();
               }
               if (!$found) { 
                   $sql = 'select collid from omcollections where institutioncode = ? ';
                   if ($statement = $connection->prepare($sql)) {
                       $statement->bind_param("s", $collectionCode);
                       $statement->execute();
                       $statement->bind_result($returnvalue);
                       $statement->store_result();
                       $statement->fetch();
               		   if ($statement->num_rows == 1) { $found = true; }
                       $statement->close();
                   }
               }
               if (!$found) {
               	 $sql = 'select distinct collid from omoccurrences where collectioncode = ? ';
               	 if ($statement = $connection->prepare($sql)) {
               		$statement->bind_param("s", $collectionCode);
               		$statement->execute();
               		$statement->bind_result($returnvalue);
                    $statement->store_result();
               		$statement->fetch();
               		if ($statement->num_rows == 1) { $found = true; }
               		$statement->close();
               	 }
               }               
               if (!$found) {
               	 $sql = 'select distinct collid from omcollections where collectioncode = ? and institutioncode is null ';
               	 if ($statement = $connection->prepare($sql)) {
               		$statement->bind_param("s", $collectionCode);
               		$statement->execute();
               		$statement->bind_result($returnvalue);
                    $statement->store_result();
               		$statement->fetch();
               		if ($statement->num_rows == 1) { $found = true; }
               		$statement->close();
               	 }
               }               
           }
       } else { 
           $found = false;
           if ($collectionCode==null || strlen($collectionCode)==0) { 
              // possible case for zoological collections, no collection code in use, just institution code.
              $sql = 'select collid from omcollections where institutioncode = ? and collectioncode is null ';
              if($collectionCode != NULL) {
                  if ($statement = $connection->prepare($sql)) {
                      $statement->bind_param("s", $institutionCode);
                      $statement->execute();
                      $statement->bind_result($returnvalue);
                      $statement->store_result();
                      $statement->fetch();
                  	   if ($statement->num_rows == 1) { $found = true; }
                      $statement->close();
                  }
              }
           } 
           if (!$found) { 
          	   // If instituion code was provided, most likely case is that the Symbiota instance is holding 
          	   // correct values for both dwc:collectionCode and dwc:institutionCode in omcollections.
              $sql = 'select collid from omcollections where institutioncode = ? and collectioncode = ? ';
              if($collectionCode != NULL) {
                  if ($statement = $connection->prepare($sql)) {
                      $statement->bind_param("ss", $institutionCode, $collectionCode);
                      $statement->execute();
                      $statement->bind_result($returnvalue);
                      $statement->store_result();
                      $statement->fetch();
                  	   if ($statement->num_rows == 1) { $found = true; }
                      $statement->close();
                  }
              }
           }
           if (!$found) { 
       	      // Failover case, the Symbiota instance is holding dwc:institutionCode in omcollections,
              // but has more that one collectioncode in omoccurrences for that collid.
              $sql = 'select distinct c.collid from omcollections c left join omoccurrences o on c.collid = o.collid where c.institutioncode = ? and o.collectioncode = ? ';
              if($collectionCode != NULL) {
                 if ($statement = $connection->prepare($sql)) {
                    $statement->bind_param("ss", $institutionCode, $collectionCode);
                    $statement->execute();
                    $statement->bind_result($returnvalue);
                    $statement->store_result();
                    $statement->fetch();
               	    if ($statement->num_rows == 1) { $found = true; }
                    $statement->close();
                 }
              }
           }
           if (!$found) { 
       	      // Failover case, the Symbiota instance is holding dwc:institutionCode and
              // dwc:collectioncode in omoccurrences.
              $sql = 'select distinct collid from omoccurrences where institutioncode = ? and collectioncode = ? ';
              if($collectionCode != NULL) {
                 if ($statement = $connection->prepare($sql)) {
                    $statement->bind_param("ss", $institutionCode, $collectionCode);
                    $statement->execute();
                    $statement->bind_result($returnvalue);
                    $statement->store_result();
                    $statement->fetch();
               	    if ($statement->num_rows == 1) { $found = true; }
                    $statement->close();
                 }
              }
           }
       }
       return $returnvalue;
   }

   /** Lookup the institution code for a collection given the symbiota collid.
    *
    * @param collid symbiota omcollections.collid pk.
    * @returns dwc:institutionCode as a string, or null if not found.
    */
   public static function lookupInstitutionCode($collid) { 
        // ******* Note: $connection must be a mysqli object.
        global $connection;
       $returnvalue = null;
       if ($collid!=null) { 
           $sql = 'select institutioncode from omcollections where collid = ? ';
           if ($statement = $connection->prepare($sql)) {
              $statement->bind_param("i", $collid);
              $statement->execute();
              $statement->bind_result($returnvalue);
              $statement->fetch();
              $statement->close();
           }
       } 
       return $returnvalue;
   }


   //----------------------- End Supporting Functions --------------------------

   //---------------------------------------------------------------------------

   public function keyValueSet($fieldname,$value) {
       $returnvalue = false;
       if ($this->hasField($fieldname)) { 
          try {
             if ($fieldname=='occid') { $returnvalue = $this->setoccid($value); } 
             if ($fieldname=='collid') { $returnvalue = $this->setcollid($value); } 
             if ($fieldname=='dbpk') { $returnvalue = $this->setdbpk($value); } 
             if ($fieldname=='basisOfRecord') { $returnvalue = $this->setbasisOfRecord($value); } 
             if ($fieldname=='occurrenceID') { $returnvalue = $this->setoccurrenceID($value); } 
             if ($fieldname=='catalogNumber') { $returnvalue = $this->setcatalogNumber($value); } 
             if ($fieldname=='otherCatalogNumbers') { $returnvalue = $this->setotherCatalogNumbers($value); } 
             if ($fieldname=='ownerInstitutionCode') { $returnvalue = $this->setownerInstitutionCode($value); } 
             if ($fieldname=='institutionID') { $returnvalue = $this->setinstitutionID($value); } 
             if ($fieldname=='collectionID') { $returnvalue = $this->setcollectionID($value); } 
             if ($fieldname=='datasetID') { $returnvalue = $this->setdatasetID($value); } 
             if ($fieldname=='institutionCode') { $returnvalue = $this->setinstitutionCode($value); } 
             if ($fieldname=='collectionCode') { $returnvalue = $this->setcollectionCode($value); } 
             if ($fieldname=='family') { $returnvalue = $this->setfamily($value); } 
             if ($fieldname=='scientificName') { $returnvalue = $this->setscientificName($value); } 
             if ($fieldname=='sciname') { $returnvalue = $this->setsciname($value); } 
             if ($fieldname=='tidinterpreted') { $returnvalue = $this->settidinterpreted($value); } 
             if ($fieldname=='genus') { $returnvalue = $this->setgenus($value); } 
             if ($fieldname=='specificEpithet') { $returnvalue = $this->setspecificEpithet($value); } 
             if ($fieldname=='taxonRank') { $returnvalue = $this->settaxonRank($value); } 
             if ($fieldname=='infraspecificEpithet') { $returnvalue = $this->setinfraspecificEpithet($value); } 
             if ($fieldname=='scientificNameAuthorship') { $returnvalue = $this->setscientificNameAuthorship($value); } 
             if ($fieldname=='taxonRemarks') { $returnvalue = $this->settaxonRemarks($value); } 
             if ($fieldname=='identifiedBy') { $returnvalue = $this->setidentifiedBy($value); } 
             if ($fieldname=='dateIdentified') { $returnvalue = $this->setdateIdentified($value); } 
             if ($fieldname=='identificationReferences') { $returnvalue = $this->setidentificationReferences($value); } 
             if ($fieldname=='identificationRemarks') { $returnvalue = $this->setidentificationRemarks($value); } 
             if ($fieldname=='identificationQualifier') { $returnvalue = $this->setidentificationQualifier($value); } 
             if ($fieldname=='typeStatus') { $returnvalue = $this->settypeStatus($value); } 
             if ($fieldname=='recordedBy') { $returnvalue = $this->setrecordedBy($value); } 
             if ($fieldname=='recordNumber') { $returnvalue = $this->setrecordNumber($value); } 
             if ($fieldname=='recordedById') { $returnvalue = $this->setrecordedById($value); } 
             if ($fieldname=='associatedCollectors') { $returnvalue = $this->setassociatedCollectors($value); } 
             if ($fieldname=='eventDate') { $returnvalue = $this->seteventDate($value); } 
             if ($fieldname=='latestDateCollected') { $returnvalue = $this->setlatestDateCollected($value); } 
             if ($fieldname=='year') { $returnvalue = $this->setyear($value); } 
             if ($fieldname=='month') { $returnvalue = $this->setmonth($value); } 
             if ($fieldname=='day') { $returnvalue = $this->setday($value); } 
             if ($fieldname=='startDayOfYear') { $returnvalue = $this->setstartDayOfYear($value); } 
             if ($fieldname=='endDayOfYear') { $returnvalue = $this->setendDayOfYear($value); } 
             if ($fieldname=='verbatimEventDate') { $returnvalue = $this->setverbatimEventDate($value); } 
             if ($fieldname=='habitat') { $returnvalue = $this->sethabitat($value); } 
             if ($fieldname=='substrate') { $returnvalue = $this->setsubstrate($value); } 
             if ($fieldname=='fieldNotes') { $returnvalue = $this->setfieldNotes($value); } 
             if ($fieldname=='fieldnumber') { $returnvalue = $this->setfieldnumber($value); } 
             if ($fieldname=='eventID') { $returnvalue = $this->seteventID($value); } 
             if ($fieldname=='occurrenceRemarks') { $returnvalue = $this->setoccurrenceRemarks($value); } 
             if ($fieldname=='informationWithheld') { $returnvalue = $this->setinformationWithheld($value); } 
             if ($fieldname=='dataGeneralizations') { $returnvalue = $this->setdataGeneralizations($value); } 
             if ($fieldname=='associatedOccurrences') { $returnvalue = $this->setassociatedOccurrences($value); } 
             if ($fieldname=='associatedTaxa') { $returnvalue = $this->setassociatedTaxa($value); } 
             if ($fieldname=='dynamicProperties') { $returnvalue = $this->setdynamicProperties($value); } 
             if ($fieldname=='verbatimAttributes') { $returnvalue = $this->setverbatimAttributes($value); } 
             if ($fieldname=='behavior') { $returnvalue = $this->setbehavior($value); } 
             if ($fieldname=='reproductiveCondition') { $returnvalue = $this->setreproductiveCondition($value); } 
             if ($fieldname=='cultivationStatus') { $returnvalue = $this->setcultivationStatus($value); } 
             if ($fieldname=='establishmentMeans') { $returnvalue = $this->setestablishmentMeans($value); } 
             if ($fieldname=='lifeStage') { $returnvalue = $this->setlifeStage($value); } 
             if ($fieldname=='sex') { $returnvalue = $this->setsex($value); } 
             if ($fieldname=='individualCount') { $returnvalue = $this->setindividualCount($value); } 
             if ($fieldname=='samplingProtocol') { $returnvalue = $this->setsamplingProtocol($value); } 
             if ($fieldname=='samplingEffort') { $returnvalue = $this->setsamplingEffort($value); } 
             if ($fieldname=='preparations') { $returnvalue = $this->setpreparations($value); } 
             if ($fieldname=='locationID') { $returnvalue = $this->setlocationID($value); } 
             if ($fieldname=='waterBody') { $returnvalue = $this->setwaterBody($value); } 
             if ($fieldname=='country') { $returnvalue = $this->setcountry($value); } 
             if ($fieldname=='stateProvince') { $returnvalue = $this->setstateProvince($value); } 
             if ($fieldname=='county') { $returnvalue = $this->setcounty($value); } 
             if ($fieldname=='municipality') { $returnvalue = $this->setmunicipality($value); } 
             if ($fieldname=='locality') { $returnvalue = $this->setlocality($value); } 
             if ($fieldname=='localitySecurity') { $returnvalue = $this->setlocalitySecurity($value); } 
             if ($fieldname=='localitySecurityReason') { $returnvalue = $this->setlocalitySecurityReason($value); } 
             if ($fieldname=='decimalLatitude') { $returnvalue = $this->setdecimalLatitude($value); } 
             if ($fieldname=='decimalLongitude') { $returnvalue = $this->setdecimalLongitude($value); } 
             if ($fieldname=='geodeticDatum') { $returnvalue = $this->setgeodeticDatum($value); } 
             if ($fieldname=='coordinateUncertaintyInMeters') { $returnvalue = $this->setcoordinateUncertaintyInMeters($value); } 
             if ($fieldname=='footprintWKT') { $returnvalue = $this->setfootprintWKT($value); } 
             if ($fieldname=='coordinatePrecision') { $returnvalue = $this->setcoordinatePrecision($value); } 
             if ($fieldname=='locationRemarks') { $returnvalue = $this->setlocationRemarks($value); } 
             if ($fieldname=='verbatimCoordinates') { $returnvalue = $this->setverbatimCoordinates($value); } 
             if ($fieldname=='verbatimCoordinateSystem') { $returnvalue = $this->setverbatimCoordinateSystem($value); } 
             if ($fieldname=='georeferencedBy') { $returnvalue = $this->setgeoreferencedBy($value); } 
             if ($fieldname=='georeferenceProtocol') { $returnvalue = $this->setgeoreferenceProtocol($value); } 
             if ($fieldname=='georeferenceSources') { $returnvalue = $this->setgeoreferenceSources($value); } 
             if ($fieldname=='georeferenceVerificationStatus') { $returnvalue = $this->setgeoreferenceVerificationStatus($value); } 
             if ($fieldname=='georeferenceRemarks') { $returnvalue = $this->setgeoreferenceRemarks($value); } 
             if ($fieldname=='minimumElevationInMeters') { $returnvalue = $this->setminimumElevationInMeters($value); } 
             if ($fieldname=='maximumElevationInMeters') { $returnvalue = $this->setmaximumElevationInMeters($value); } 
             if ($fieldname=='verbatimElevation') { $returnvalue = $this->setverbatimElevation($value); } 
             if ($fieldname=='previousIdentifications') { $returnvalue = $this->setpreviousIdentifications($value); } 
             if ($fieldname=='disposition') { $returnvalue = $this->setdisposition($value); } 
             if ($fieldname=='genericcolumn1') { $returnvalue = $this->setgenericcolumn1($value); } 
             if ($fieldname=='genericcolumn2') { $returnvalue = $this->setgenericcolumn2($value); } 
             if ($fieldname=='modified') { $returnvalue = $this->setmodified($value); } 
             if ($fieldname=='language') { $returnvalue = $this->setlanguage($value); } 
             if ($fieldname=='observeruid') { $returnvalue = $this->setobserveruid($value); } 
             if ($fieldname=='processingstatus') { $returnvalue = $this->setprocessingstatus($value); } 
             if ($fieldname=='recordEnteredBy') { $returnvalue = $this->setrecordEnteredBy($value); } 
             if ($fieldname=='duplicateQuantity') { $returnvalue = $this->setduplicateQuantity($value); } 
             if ($fieldname=='labelProject') { $returnvalue = $this->setlabelProject($value); } 
             if ($fieldname=='dynamicFields') { $returnvalue = $this->setdynamicFields($value); } 
             if ($fieldname=='dateEntered') { $returnvalue = $this->setdateEntered($value); } 
             if ($fieldname=='dateLastModified') { $returnvalue = $this->setdateLastModified($value); } 
             if ($fieldname=='minimumDepthInMeters') { $returnvalue = $this->setminimumDepthInMeters($value); }
             if ($fieldname=='maximumDepthInMeters') { $returnvalue = $this->setmaximumDepthInMeters($value); }
             if ($fieldname=='verbatimDepth') { $returnvalue = $this->setverbatimDepth($value); }
             if ($fieldname=='storageLocation') { $returnvalue = $this->setstorageLocation($value); }
             $returnvalue = true;
          }
          catch (exception $e) { ;
              $returnvalue = false;
              throw new Exception('Field Set Error'.$e->getMessage()); 
          }
       } else { 
          throw new Exception('No Such field'); 
       }  
       return $returnvalue;
   }
   public function keyGet($fieldname) {
       $returnvalue = null;
       if ($this->hasField($fieldname)) { 
          try {
             if ($fieldname=='occid') { $returnvalue = $this->getoccid(); } 
             if ($fieldname=='collid') { $returnvalue = $this->getcollid(); } 
             if ($fieldname=='dbpk') { $returnvalue = $this->getdbpk(); } 
             if ($fieldname=='basisOfRecord') { $returnvalue = $this->getbasisOfRecord(); } 
             if ($fieldname=='occurrenceID') { $returnvalue = $this->getoccurrenceID(); } 
             if ($fieldname=='catalogNumber') { $returnvalue = $this->getcatalogNumber(); } 
             if ($fieldname=='otherCatalogNumbers') { $returnvalue = $this->getotherCatalogNumbers(); } 
             if ($fieldname=='ownerInstitutionCode') { $returnvalue = $this->getownerInstitutionCode(); } 
             if ($fieldname=='institutionID') { $returnvalue = $this->getinstitutionID(); } 
             if ($fieldname=='collectionID') { $returnvalue = $this->getcollectionID(); } 
             if ($fieldname=='datasetID') { $returnvalue = $this->getdatasetID(); } 
             if ($fieldname=='institutionCode') { $returnvalue = $this->getinstitutionCode(); } 
             if ($fieldname=='collectionCode') { $returnvalue = $this->getcollectionCode(); } 
             if ($fieldname=='family') { $returnvalue = $this->getfamily(); } 
             if ($fieldname=='scientificName') { $returnvalue = $this->getscientificName(); } 
             if ($fieldname=='sciname') { $returnvalue = $this->getsciname(); } 
             if ($fieldname=='tidinterpreted') { $returnvalue = $this->gettidinterpreted(); } 
             if ($fieldname=='genus') { $returnvalue = $this->getgenus(); } 
             if ($fieldname=='specificEpithet') { $returnvalue = $this->getspecificEpithet(); } 
             if ($fieldname=='taxonRank') { $returnvalue = $this->gettaxonRank(); } 
             if ($fieldname=='infraspecificEpithet') { $returnvalue = $this->getinfraspecificEpithet(); } 
             if ($fieldname=='scientificNameAuthorship') { $returnvalue = $this->getscientificNameAuthorship(); } 
             if ($fieldname=='taxonRemarks') { $returnvalue = $this->gettaxonRemarks(); } 
             if ($fieldname=='identifiedBy') { $returnvalue = $this->getidentifiedBy(); } 
             if ($fieldname=='dateIdentified') { $returnvalue = $this->getdateIdentified(); } 
             if ($fieldname=='identificationReferences') { $returnvalue = $this->getidentificationReferences(); } 
             if ($fieldname=='identificationRemarks') { $returnvalue = $this->getidentificationRemarks(); } 
             if ($fieldname=='identificationQualifier') { $returnvalue = $this->getidentificationQualifier(); } 
             if ($fieldname=='typeStatus') { $returnvalue = $this->gettypeStatus(); } 
             if ($fieldname=='recordedBy') { $returnvalue = $this->getrecordedBy(); } 
             if ($fieldname=='recordNumber') { $returnvalue = $this->getrecordNumber(); } 
             if ($fieldname=='recordedById') { $returnvalue = $this->getrecordedById(); } 
             if ($fieldname=='associatedCollectors') { $returnvalue = $this->getassociatedCollectors(); } 
             if ($fieldname=='eventDate') { $returnvalue = $this->geteventDate(); } 
             if ($fieldname=='latestDateCollected') { $returnvalue = $this->getlatestDateCollected(); } 
             if ($fieldname=='year') { $returnvalue = $this->getyear(); } 
             if ($fieldname=='month') { $returnvalue = $this->getmonth(); } 
             if ($fieldname=='day') { $returnvalue = $this->getday(); } 
             if ($fieldname=='startDayOfYear') { $returnvalue = $this->getstartDayOfYear(); } 
             if ($fieldname=='endDayOfYear') { $returnvalue = $this->getendDayOfYear(); } 
             if ($fieldname=='verbatimEventDate') { $returnvalue = $this->getverbatimEventDate(); } 
             if ($fieldname=='habitat') { $returnvalue = $this->gethabitat(); } 
             if ($fieldname=='substrate') { $returnvalue = $this->getsubstrate(); } 
             if ($fieldname=='fieldNotes') { $returnvalue = $this->getfieldNotes(); } 
             if ($fieldname=='fieldnumber') { $returnvalue = $this->getfieldnumber(); } 
             if ($fieldname=='eventID') { $returnvalue = $this->geteventID(); } 
             if ($fieldname=='occurrenceRemarks') { $returnvalue = $this->getoccurrenceRemarks(); } 
             if ($fieldname=='informationWithheld') { $returnvalue = $this->getinformationWithheld(); } 
             if ($fieldname=='dataGeneralizations') { $returnvalue = $this->getdataGeneralizations(); } 
             if ($fieldname=='associatedOccurrences') { $returnvalue = $this->getassociatedOccurrences(); } 
             if ($fieldname=='associatedTaxa') { $returnvalue = $this->getassociatedTaxa(); } 
             if ($fieldname=='dynamicProperties') { $returnvalue = $this->getdynamicProperties(); } 
             if ($fieldname=='verbatimAttributes') { $returnvalue = $this->getverbatimAttributes(); } 
             if ($fieldname=='behavior') { $returnvalue = $this->getbehavior(); } 
             if ($fieldname=='reproductiveCondition') { $returnvalue = $this->getreproductiveCondition(); } 
             if ($fieldname=='cultivationStatus') { $returnvalue = $this->getcultivationStatus(); } 
             if ($fieldname=='establishmentMeans') { $returnvalue = $this->getestablishmentMeans(); } 
             if ($fieldname=='lifeStage') { $returnvalue = $this->getlifeStage(); } 
             if ($fieldname=='sex') { $returnvalue = $this->getsex(); } 
             if ($fieldname=='individualCount') { $returnvalue = $this->getindividualCount(); } 
             if ($fieldname=='samplingProtocol') { $returnvalue = $this->getsamplingProtocol(); } 
             if ($fieldname=='samplingEffort') { $returnvalue = $this->getsamplingEffort(); } 
             if ($fieldname=='preparations') { $returnvalue = $this->getpreparations(); } 
             if ($fieldname=='getlocationID') { $returnvalue = $this->getlocationID(); } 
             if ($fieldname=='waterBody') { $returnvalue = $this->getwaterBody(); } 
             if ($fieldname=='country') { $returnvalue = $this->getcountry(); } 
             if ($fieldname=='stateProvince') { $returnvalue = $this->getstateProvince(); } 
             if ($fieldname=='county') { $returnvalue = $this->getcounty(); } 
             if ($fieldname=='municipality') { $returnvalue = $this->getmunicipality(); } 
             if ($fieldname=='locality') { $returnvalue = $this->getlocality(); } 
             if ($fieldname=='localitySecurity') { $returnvalue = $this->getlocalitySecurity(); } 
             if ($fieldname=='localitySecurityReason') { $returnvalue = $this->getlocalitySecurityReason(); } 
             if ($fieldname=='decimalLatitude') { $returnvalue = $this->getdecimalLatitude(); } 
             if ($fieldname=='decimalLongitude') { $returnvalue = $this->getdecimalLongitude(); } 
             if ($fieldname=='geodeticDatum') { $returnvalue = $this->getgeodeticDatum(); } 
             if ($fieldname=='coordinateUncertaintyInMeters') { $returnvalue = $this->getcoordinateUncertaintyInMeters(); } 
             if ($fieldname=='footprintWKT') { $returnvalue = $this->getfootprintWKT(); } 
             if ($fieldname=='coordinatePrecision') { $returnvalue = $this->getcoordinatePrecision(); } 
             if ($fieldname=='locationRemarks') { $returnvalue = $this->getlocationRemarks(); } 
             if ($fieldname=='verbatimCoordinates') { $returnvalue = $this->getverbatimCoordinates(); } 
             if ($fieldname=='verbatimCoordinateSystem') { $returnvalue = $this->getverbatimCoordinateSystem(); } 
             if ($fieldname=='georeferencedBy') { $returnvalue = $this->getgeoreferencedBy(); } 
             if ($fieldname=='georeferenceProtocol') { $returnvalue = $this->getgeoreferenceProtocol(); } 
             if ($fieldname=='georeferenceSources') { $returnvalue = $this->getgeoreferenceSources(); } 
             if ($fieldname=='georeferenceVerificationStatus') { $returnvalue = $this->getgeoreferenceVerificationStatus(); } 
             if ($fieldname=='georeferenceRemarks') { $returnvalue = $this->getgeoreferenceRemarks(); } 
             if ($fieldname=='minimumElevationInMeters') { $returnvalue = $this->getminimumElevationInMeters(); } 
             if ($fieldname=='maximumElevationInMeters') { $returnvalue = $this->getmaximumElevationInMeters(); } 
             if ($fieldname=='verbatimElevation') { $returnvalue = $this->getverbatimElevation(); } 
             if ($fieldname=='previousIdentifications') { $returnvalue = $this->getpreviousIdentifications(); } 
             if ($fieldname=='disposition') { $returnvalue = $this->getdisposition(); } 
             if ($fieldname=='genericcolumn1') { $returnvalue = $this->getgenericcolumn1(); } 
             if ($fieldname=='genericcolumn2') { $returnvalue = $this->getgenericcolumn2(); } 
             if ($fieldname=='modified') { $returnvalue = $this->getmodified(); } 
             if ($fieldname=='language') { $returnvalue = $this->getlanguage(); } 
             if ($fieldname=='observeruid') { $returnvalue = $this->getobserveruid(); } 
             if ($fieldname=='processingstatus') { $returnvalue = $this->getprocessingstatus(); } 
             if ($fieldname=='recordEnteredBy') { $returnvalue = $this->getrecordEnteredBy(); } 
             if ($fieldname=='duplicateQuantity') { $returnvalue = $this->getduplicateQuantity(); } 
             if ($fieldname=='labelProject') { $returnvalue = $this->getlabelProject(); } 
             if ($fieldname=='dynamicFields') { $returnvalue = $this->getdynamicFields(); } 
             if ($fieldname=='dateEntered') { $returnvalue = $this->getdateEntered(); } 
             if ($fieldname=='dateLastModified') { $returnvalue = $this->getdateLastModified(); } 
             if ($fieldname=='minimumDepthInMeters') { $returnvalue = $this->getminimumDepthInMeters(); }
             if ($fieldname=='maximumDepthInMeters') { $returnvalue = $this->getmaximumDepthInMeters(); }
             if ($fieldname=='verbatimDepth') { $returnvalue = $this->getverbatimDepth(); }
             if ($fieldname=='storageLocation') { $returnvalue = $this->getstorageLocation(); }
          }
          catch (exception $e) { ;
              $returnvalue = null;
          }
       }
       return $returnvalue;
   }
/*occid*/
   public function getoccid() {
       if ($this->occid==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->occid));
       }
   }
   public function setoccid($occid) {
       if (strlen(preg_replace('/[^0-9]/','',$occid)) > omoccurrences::OCCID_SIZE) { 
           throw new Exception('Value has too many digits for the field length.');
       } 
       $occid = trim($occid);
       if (!ctype_digit(strval($occid)) && trim(strval($occid))!='' ) {
             throw new Exception("Value must be an integer");
       }
       $this->occid = $this->l_addslashes($occid);
       $this->dirty = true;
   }
/*collid*/
   public function getcollid() {
       if ($this->collid==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->collid));
       }
   }
   public function setcollid($collid) {
       if (strlen($collid) > omoccurrences::COLLID_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->collid = $this->l_addslashes($collid);
       $this->dirty = true;
   }
/*dbpk*/
   public function getdbpk() {
       if ($this->dbpk==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->dbpk));
       }
   }
   public function setdbpk($dbpk) {
       if (strlen($dbpk) > omoccurrences::DBPK_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->dbpk = $this->l_addslashes($dbpk);
       $this->dirty = true;
   }
/*basisOfRecord*/
   public function getbasisOfRecord() {
       if ($this->basisOfRecord==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->basisOfRecord));
       }
   }
   public function setbasisOfRecord($basisOfRecord) {
       if (strlen($basisOfRecord) > omoccurrences::BASISOFRECORD_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->basisOfRecord = $this->l_addslashes($basisOfRecord);
       $this->dirty = true;
   }
/*occurrenceID*/
   public function getoccurrenceID() {
       if ($this->occurrenceID==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->occurrenceID));
       }
   }
   public function setoccurrenceID($occurrenceID) {
       if (strlen($occurrenceID) > omoccurrences::OCCURRENCEID_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->occurrenceID = $this->l_addslashes($occurrenceID);
       $this->dirty = true;
   }
/*catalogNumber*/
   public function getcatalogNumber() {
       if ($this->catalogNumber==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->catalogNumber));
       }
   }
   public function setcatalogNumber($catalogNumber) {
       if (strlen($catalogNumber) > omoccurrences::CATALOGNUMBER_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->catalogNumber = $this->l_addslashes($catalogNumber);
       $this->dirty = true;
   }
/*otherCatalogNumbers*/
   public function getotherCatalogNumbers() {
       if ($this->otherCatalogNumbers==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->otherCatalogNumbers));
       }
   }
   public function setotherCatalogNumbers($otherCatalogNumbers) {
       if (strlen($otherCatalogNumbers) > omoccurrences::OTHERCATALOGNUMBERS_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->otherCatalogNumbers = $this->l_addslashes($otherCatalogNumbers);
       $this->dirty = true;
   }
/*ownerInstitutionCode*/
   public function getownerInstitutionCode() {
       if ($this->ownerInstitutionCode==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->ownerInstitutionCode));
       }
   }
   public function setownerInstitutionCode($ownerInstitutionCode) {
       if (strlen($ownerInstitutionCode) > omoccurrences::OWNERINSTITUTIONCODE_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->ownerInstitutionCode = $this->l_addslashes($ownerInstitutionCode);
       $this->dirty = true;
   }
/*institutionID*/
   public function getinstitutionID() {
       if ($this->institutionID==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->institutionID));
       }
   }
   public function setinstitutionID($institutionID) {
       if (strlen($institutionID) > omoccurrences::INSTITUTIONID_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->institutionID = $this->l_addslashes($institutionID);
       $this->dirty = true;
   }
/*collectionID*/
   public function getcollectionID() {
       if ($this->collectionID==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->collectionID));
       }
   }
   public function setcollectionID($collectionID) {
       if (strlen($collectionID) > omoccurrences::COLLECTIONID_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->collectionID = $this->l_addslashes($collectionID);
       $this->dirty = true;
   }
/*datasetID*/
   public function getdatasetID() {
       if ($this->datasetID==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->datasetID));
       }
   }
   public function setdatasetID($datasetID) {
       if (strlen($datasetID) > omoccurrences::DATASETID_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->datasetID = $this->l_addslashes($datasetID);
       $this->dirty = true;
   }
/*institutionCode*/
   public function getinstitutionCode() {
       global $connection;
       if ($this->institutionCode==null) { 
          if ($this->collid==null) {
             return null;
          } else {
             // lookup the institution code from the collectionid 
             $result = null;
             $sql = "select collectioncode from omcollections where collid = ? ";
             $stmt= $connection->stmt_init();
             $stmt->prepare($sql);
             $stmt->bind_param('i',$this->collid);
             if ($stmt->execute()) {
                $stmt->bind_result($result);
                $stmt->fetch();
             }
             $stmt->close();
             return $result;
          }
       } else { ;
          return trim($this->l_stripslashes($this->institutionCode));
       }
   }
   public function setinstitutionCode($institutionCode) {
       if (strlen($institutionCode) > omoccurrences::INSTITUTIONCODE_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->institutionCode = $this->l_addslashes($institutionCode);
       $this->dirty = true;
   }
/*collectionCode*/
   public function getcollectionCode() {
       global $connection;
       if ($this->collectionCode==null) { 
          if ($this->collid==null) { 
             return null;
          } else { 
             // lookup the collection code from the collectionid 
             $result = null;
             $sql = "select collectioncode from omcollections where collid = ? ";
             $stmt= $connection->stmt_init();
             $stmt->prepare($sql);
             $stmt->bind_param('i',$this->collid);
             if ($stmt->execute()) { 
                $stmt->bind_result($result);
                $stmt->fetch();
             } 
             $stmt->close();
             return $result;
          }
       } else { ;
          return trim($this->l_stripslashes($this->collectionCode));
       }
   }
   public function setcollectionCode($collectionCode) {
       if (strlen($collectionCode) > omoccurrences::COLLECTIONCODE_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->collectionCode = $this->l_addslashes($collectionCode);
       $this->dirty = true;
   }
/*family*/
   public function getfamily() {
       if ($this->family==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->family));
       }
   }
   public function setfamily($family) {
       if (strlen($family) > omoccurrences::FAMILY_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->family = $this->l_addslashes($family);
       $this->dirty = true;
   }
/*scientificName*/
   public function getscientificName() {
       if ($this->scientificName==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->scientificName));
       }
   }
   public function setscientificName($scientificName) {
       if (strlen($scientificName) > omoccurrences::SCIENTIFICNAME_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->scientificName = $this->l_addslashes($scientificName);
       $this->dirty = true;
   }
/*sciname*/
   public function getsciname() {
       if ($this->sciname==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->sciname));
       }
   }
   public function setsciname($sciname) {
       if (strlen($sciname) > omoccurrences::SCINAME_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->sciname = $this->l_addslashes($sciname);
       $this->dirty = true;
   }
/*tidinterpreted*/
   public function gettidinterpreted() {
       if ($this->tidinterpreted==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->tidinterpreted));
       }
   }
   public function settidinterpreted($tidinterpreted) {
       if (strlen($tidinterpreted) > omoccurrences::TIDINTERPRETED_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->tidinterpreted = $this->l_addslashes($tidinterpreted);
       $this->dirty = true;
   }
/*genus*/
   public function getgenus() {
       if ($this->genus==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->genus));
       }
   }
   public function setgenus($genus) {
       if (strlen($genus) > omoccurrences::GENUS_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->genus = $this->l_addslashes($genus);
       $this->dirty = true;
   }
/*specificEpithet*/
   public function getspecificEpithet() {
       if ($this->specificEpithet==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->specificEpithet));
       }
   }
   public function setspecificEpithet($specificEpithet) {
       if (strlen($specificEpithet) > omoccurrences::SPECIFICEPITHET_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->specificEpithet = $this->l_addslashes($specificEpithet);
       $this->dirty = true;
   }
/*taxonRank*/
   public function gettaxonRank() {
       if ($this->taxonRank==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->taxonRank));
       }
   }
   public function settaxonRank($taxonRank) {
       if (strlen($taxonRank) > omoccurrences::TAXONRANK_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->taxonRank = $this->l_addslashes($taxonRank);
       $this->dirty = true;
   }
/*infraspecificEpithet*/
   public function getinfraspecificEpithet() {
       if ($this->infraspecificEpithet==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->infraspecificEpithet));
       }
   }
   public function setinfraspecificEpithet($infraspecificEpithet) {
       if (strlen($infraspecificEpithet) > omoccurrences::INFRASPECIFICEPITHET_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->infraspecificEpithet = $this->l_addslashes($infraspecificEpithet);
       $this->dirty = true;
   }
/*scientificNameAuthorship*/
   public function getscientificNameAuthorship() {
       if ($this->scientificNameAuthorship==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->scientificNameAuthorship));
       }
   }
   public function setscientificNameAuthorship($scientificNameAuthorship) {
       if (strlen($scientificNameAuthorship) > omoccurrences::SCIENTIFICNAMEAUTHORSHIP_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->scientificNameAuthorship = $this->l_addslashes($scientificNameAuthorship);
       $this->dirty = true;
   }
/*taxonRemarks*/
   public function gettaxonRemarks() {
       if ($this->taxonRemarks==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->taxonRemarks));
       }
   }
   public function settaxonRemarks($taxonRemarks) {
       if (strlen($taxonRemarks) > omoccurrences::TAXONREMARKS_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->taxonRemarks = $this->l_addslashes($taxonRemarks);
       $this->dirty = true;
   }
/*identifiedBy*/
   public function getidentifiedBy() {
       if ($this->identifiedBy==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->identifiedBy));
       }
   }
   public function setidentifiedBy($identifiedBy) {
       if (strlen($identifiedBy) > omoccurrences::IDENTIFIEDBY_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->identifiedBy = $this->l_addslashes($identifiedBy);
       $this->dirty = true;
   }
/*dateIdentified*/
   public function getdateIdentified() {
       if ($this->dateIdentified==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->dateIdentified));
       }
   }
   public function setdateIdentified($dateIdentified) {
       if (strlen($dateIdentified) > omoccurrences::DATEIDENTIFIED_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->dateIdentified = $this->l_addslashes($dateIdentified);
       $this->dirty = true;
   }
/*identificationReferences*/
   public function getidentificationReferences() {
       if ($this->identificationReferences==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->identificationReferences));
       }
   }
   public function setidentificationReferences($identificationReferences) {
       if (strlen($identificationReferences) > omoccurrences::IDENTIFICATIONREFERENCES_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->identificationReferences = $this->l_addslashes($identificationReferences);
       $this->dirty = true;
   }
/*identificationRemarks*/
   public function getidentificationRemarks() {
       if ($this->identificationRemarks==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->identificationRemarks));
       }
   }
   public function setidentificationRemarks($identificationRemarks) {
       if (strlen($identificationRemarks) > omoccurrences::IDENTIFICATIONREMARKS_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->identificationRemarks = $this->l_addslashes($identificationRemarks);
       $this->dirty = true;
   }
/*identificationQualifier*/
   public function getidentificationQualifier() {
       if ($this->identificationQualifier==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->identificationQualifier));
       }
   }
   public function setidentificationQualifier($identificationQualifier) {
       if (strlen($identificationQualifier) > omoccurrences::IDENTIFICATIONQUALIFIER_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->identificationQualifier = $this->l_addslashes($identificationQualifier);
       $this->dirty = true;
   }
/*typeStatus*/
   public function gettypeStatus() {
       if ($this->typeStatus==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->typeStatus));
       }
   }
   public function settypeStatus($typeStatus) {
       if (strlen($typeStatus) > omoccurrences::TYPESTATUS_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->typeStatus = $this->l_addslashes($typeStatus);
       $this->dirty = true;
   }
/*recordedBy*/
   public function getrecordedBy() {
       if ($this->recordedBy==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->recordedBy));
       }
   }
   public function setrecordedBy($recordedBy) {
       if (strlen($recordedBy) > omoccurrences::RECORDEDBY_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->recordedBy = $this->l_addslashes($recordedBy);
       $this->dirty = true;
   }
/*recordNumber*/
   public function getrecordNumber() {
       if ($this->recordNumber==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->recordNumber));
       }
   }
   public function setrecordNumber($recordNumber) {
       if (strlen($recordNumber) > omoccurrences::RECORDNUMBER_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->recordNumber = $this->l_addslashes($recordNumber);
       $this->dirty = true;
   }
/*recordedById*/
   public function getrecordedById() {
       if ($this->recordedById==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->recordedById));
       }
   }
   public function setrecordedById($recordedById) {
       if (strlen($recordedById) > omoccurrences::RECORDEDBYID_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->recordedById = $this->l_addslashes($recordedById);
       $this->dirty = true;
   }
/*associatedCollectors*/
   public function getassociatedCollectors() {
       if ($this->associatedCollectors==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->associatedCollectors));
       }
   }
   public function setassociatedCollectors($associatedCollectors) {
       if (strlen($associatedCollectors) > omoccurrences::ASSOCIATEDCOLLECTORS_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->associatedCollectors = $this->l_addslashes($associatedCollectors);
       $this->dirty = true;
   }
/*eventDate*/
   public function geteventDate() {
       if ($this->eventDate==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->eventDate));
       }
   }

   /**
    * Take an ISO date and set the value of the date field eventDate, 
    * and, if a range in the same year is provided, set the 
    * values of startDayOfYear and endDayOfYear.
    *
    * @param eventDate in ISO date format (e.g. 0000-00-00/0000-00-00
    *   or 0000-00-00).
    */
   public function seteventDate($eventDate) {
       if (strlen($eventDate) > omoccurrences::EVENTDATE_SIZE) { 
           // A range was provided, parse it into start and end dates.
           $dateArr = explode('/',$eventDate);
           if (count($dateArr)<>2) { 
                throw new Exception("Date range [$eventDate] not in expected 0000-00-00/0000-00-00 form.");
           } else { 
               if (strlen($dateArr[0]) > omoccurrences::EVENTDATE_SIZE) { 
                  throw new Exception('Value exceeds field length.');
               } else { 
                  // set the event date as the first part of the provided range.
                  $this->eventDate = $this->l_addslashes($dateArr[0]);
                  if (substr($dateArr[0],0,4)==substr($dateArr[1],0,4)) { 
                     // date range is in same year, set start/end days of year.
                     $this->startDayOfYear = $this->getDayOfYear($dateArr[0],true);
                     $this->endDayOfYear = $this->getDayOfYear($dateArr[1],false);
                  }
               }
           }
       } else { 
           $this->eventDate = $this->l_addslashes($eventDate);
       }
       $this->dirty = true;
   }

   public function getlatestDateCollected() {
       if ($this->latestDateCollected==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->latestDateCollected));
       }
   }
   public function setlatestDateCollected($latestDateCollected) {
       if (strlen($latestDateCollected) > omoccurrences::LATESTDATECOLLECTED_SIZE) { 
           throw new Exception('Value exceeds field length.');
       }
       $this->latestDateCollected = $this->l_addslashes($latestDateCollected);
       $this->dirty = true;
   }
   
   /**
    * Given a date, return the day of year for that date, assuming a gregorian calendar date.
    * @param the date for which to get the day of the year.
    * @param lower, if true, and date isn't specified to day, assume lower bound is desired
    *   if false, assume upper bound is desired, e.g. for 1880/01,true return 1, for 
        1880/01,false return 31.
    * @return an integer representing the day of the year from 1 to 365.
    */
   public function getDayOfYear($date,$lower=true) {
      if ($lower) { 
        if (strlen($date==4)) { $date = "$date-01-01"; }
        if (strlen($date==7)) { $date = "$date-01"; }
      } else { 
        if (strlen($date==4)) { $date = "$date-12-31"; }
        if (strlen($date==7)) { 
           $dateArray = date_parse($date);
           $m = cal_days_in_month(CAL_GREGORIAN, $dateArray['month'], $dateArray['year']);
           $date = "$date-$m";
         }
      }
      $dateArr = date_parse($date);
      return GregorianToJD($dateArr['month'], $dateArr['day'], $dateArr['year']) - GregorianToJD(1, 1, $dateArr['year']) + 1;
   }
/*year*/
   public function getyear() {
       if ($this->year==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->year));
       }
   }
   public function setyear($year) {
       if (strlen(preg_replace('/[^0-9]/','',$year)) > omoccurrences::YEAR_SIZE) { 
           throw new Exception('Value has too many digits for the field length.');
       } 
       $year = trim($year);
       if (!ctype_digit(strval($year)) && trim(strval($year))!='' ) {
             throw new Exception("Value must be an integer");
       }
       $this->year = $this->l_addslashes($year);
       $this->dirty = true;
   }
/*month*/
   public function getmonth() {
       if ($this->month==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->month));
       }
   }
   public function setmonth($month) {
       if (strlen(preg_replace('/[^0-9]/','',$month)) > omoccurrences::MONTH_SIZE) { 
           throw new Exception('Value has too many digits for the field length.');
       } 
       $month = trim($month);
       if (!ctype_digit(strval($month)) && trim(strval($month))!='' ) {
             throw new Exception("Value must be an integer");
       }
       $this->month = $this->l_addslashes($month);
       $this->dirty = true;
   }
/*day*/
   public function getday() {
       if ($this->day==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->day));
       }
   }
   public function setday($day) {
       if (strlen(preg_replace('/[^0-9]/','',$day)) > omoccurrences::DAY_SIZE) { 
           throw new Exception('Value has too many digits for the field length.');
       } 
       $day = trim($day);
       if (!ctype_digit(strval($day)) && trim(strval($day))!='' ) {
             throw new Exception("Value must be an integer");
       }
       $this->day = $this->l_addslashes($day);
       $this->dirty = true;
   }
/*startDayOfYear*/
  public function getstartDayOfYear() {
      if ($this->startDayOfYear==null) { 
         return null;
      } else { ;
         return trim($this->l_stripslashes($this->startDayOfYear));
      }
  }
  public function setstartDayOfYear($startDayOfYear) {
      if (strlen(preg_replace('/[^0-9]/','',$startDayOfYear)) > omoccurrences::STARTDAYOFYEAR_SIZE) { 
          throw new Exception('Value has too many digits for the field length.');
      } 
      $startDayOfYear = trim($startDayOfYear);
      if (!ctype_digit(strval($startDayOfYear)) && trim(strval($startDayOfYear))!='' ) {
            throw new Exception("Value must be an integer");
      }
      $this->startDayOfYear = $this->l_addslashes($startDayOfYear);
      $this->dirty = true;
  }
/*endDayOfYear*/
  public function getendDayOfYear() {
      if ($this->endDayOfYear==null) { 
         return null;
      } else { ;
         return trim($this->l_stripslashes($this->endDayOfYear));
      }
  }
  public function setendDayOfYear($endDayOfYear) {
      if (strlen(preg_replace('/[^0-9]/','',$endDayOfYear)) > omoccurrences::ENDDAYOFYEAR_SIZE) { 
          throw new Exception('Value has too many digits for the field length.');
      } 
      $endDayOfYear = trim($endDayOfYear);
      if (!ctype_digit(strval($endDayOfYear)) && trim(strval($endDayOfYear))!='' ) {
            throw new Exception("Value must be an integer");
      }
       $this->endDayOfYear = $this->l_addslashes($endDayOfYear);
       $this->dirty = true;
   }
/*verbatimEventDate*/
   public function getverbatimEventDate() {
       if ($this->verbatimEventDate==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->verbatimEventDate));
       }
   }
   public function setverbatimEventDate($verbatimEventDate) {
       if (strlen($verbatimEventDate) > omoccurrences::VERBATIMEVENTDATE_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->verbatimEventDate = $this->l_addslashes($verbatimEventDate);
       $this->dirty = true;
   }
/*habitat*/
   public function gethabitat() {
       if ($this->habitat==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->habitat));
       }
   }
   public function sethabitat($habitat) {
       if (strlen($habitat) > omoccurrences::HABITAT_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->habitat = $this->l_addslashes($habitat);
       $this->dirty = true;
   }
/*substrate*/
   public function getsubstrate() {
       if ($this->substrate==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->substrate));
       }
   }
   public function setsubstrate($substrate) {
       if (strlen($substrate) > omoccurrences::SUBSTRATE_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->substrate = $this->l_addslashes($substrate);
       $this->dirty = true;
   }
/*fieldNotes*/
   public function getfieldNotes() {
       if ($this->fieldNotes==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->fieldNotes));
       }
   }
   public function setfieldNotes($fieldNotes) {
       if (strlen($fieldNotes) > omoccurrences::FIELDNOTES_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->fieldNotes = $this->l_addslashes($fieldNotes);
       $this->dirty = true;
   }
/*fieldnumber*/
   public function getfieldnumber() {
       if ($this->fieldnumber==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->fieldnumber));
       }
   }
   public function setfieldnumber($fieldnumber) {
       if (strlen($fieldnumber) > omoccurrences::FIELDNUMBER_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->fieldnumber = $this->l_addslashes($fieldnumber);
       $this->dirty = true;
   }
/*eventID*/
   public function geteventID() {
       if ($this->eventID==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->eventID));
       }
   }
   public function seteventID($eventID) {
       if (strlen($eventID) > omoccurrences::EVENTID_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->eventID = $this->l_addslashes($eventID);
       $this->dirty = true;
   }
/*occurrenceRemarks*/
   public function getoccurrenceRemarks() {
       if ($this->occurrenceRemarks==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->occurrenceRemarks));
       }
   }
   public function setoccurrenceRemarks($occurrenceRemarks) {
       if (strlen($occurrenceRemarks) > omoccurrences::OCCURRENCEREMARKS_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->occurrenceRemarks = $this->l_addslashes($occurrenceRemarks);
       $this->dirty = true;
   }
/*informationWithheld*/
   public function getinformationWithheld() {
       if ($this->informationWithheld==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->informationWithheld));
       }
   }
   public function setinformationWithheld($informationWithheld) {
       if (strlen($informationWithheld) > omoccurrences::INFORMATIONWITHHELD_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->informationWithheld = $this->l_addslashes($informationWithheld);
       $this->dirty = true;
   }
/*dataGeneralizations*/
   public function getdataGeneralizations() {
       if ($this->dataGeneralizations==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->dataGeneralizations));
       }
   }
   public function setdataGeneralizations($dataGeneralizations) {
       if (strlen($dataGeneralizations) > omoccurrences::DATAGENERALIZATIONS_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->dataGeneralizations = $this->l_addslashes($dataGeneralizations);
       $this->dirty = true;
   }
/*associatedOccurrences*/
   public function getassociatedOccurrences() {
       if ($this->associatedOccurrences==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->associatedOccurrences));
       }
   }
   public function setassociatedOccurrences($associatedOccurrences) {
       if (strlen($associatedOccurrences) > omoccurrences::ASSOCIATEDOCCURRENCES_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->associatedOccurrences = $this->l_addslashes($associatedOccurrences);
       $this->dirty = true;
   }
/*associatedTaxa*/
   public function getassociatedTaxa() {
       if ($this->associatedTaxa==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->associatedTaxa));
       }
   }
   public function setassociatedTaxa($associatedTaxa) {
       if (strlen($associatedTaxa) > omoccurrences::ASSOCIATEDTAXA_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->associatedTaxa = $this->l_addslashes($associatedTaxa);
       $this->dirty = true;
   }
/*dynamicProperties*/
   public function getdynamicProperties() {
       if ($this->dynamicProperties==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->dynamicProperties));
       }
   }
   public function setdynamicProperties($dynamicProperties) {
       if (strlen($dynamicProperties) > omoccurrences::DYNAMICPROPERTIES_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->dynamicProperties = $this->l_addslashes($dynamicProperties);
       $this->dirty = true;
   }
/*verbatimAttributes*/
   public function getverbatimAttributes() {
       if ($this->verbatimAttributes==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->verbatimAttributes));
       }
   }
   public function setverbatimAttributes($verbatimAttributes) {
       if (strlen($verbatimAttributes) > omoccurrences::VERBATIMATTRIBUTES_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->verbatimAttributes = $this->l_addslashes($verbatimAttributes);
       $this->dirty = true;
   }
/*behavior*/
   public function getbehavior() {
       if ($this->behavior==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->behavior));
       }
   }
   public function setbehavior($behavior) {
       if (strlen($behavior) > omoccurrences::BEHAVIOR_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->behavior = $this->l_addslashes($behavior);
       $this->dirty = true;
   }
/*reproductiveCondition*/
   public function getreproductiveCondition() {
       if ($this->reproductiveCondition==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->reproductiveCondition));
       }
   }
   public function setreproductiveCondition($reproductiveCondition) {
       if (strlen($reproductiveCondition) > omoccurrences::REPRODUCTIVECONDITION_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->reproductiveCondition = $this->l_addslashes($reproductiveCondition);
       $this->dirty = true;
   }
/*cultivationStatus*/
   public function getcultivationStatus() {
       if ($this->cultivationStatus==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->cultivationStatus));
       }
   }
   public function setcultivationStatus($cultivationStatus) {
       if (strlen(preg_replace('/[^0-9]/','',$cultivationStatus)) > omoccurrences::CULTIVATIONSTATUS_SIZE) { 
           throw new Exception('Value has too many digits for the field length.');
       } 
       $cultivationStatus = trim($cultivationStatus);
       if (!ctype_digit(strval($cultivationStatus)) && trim(strval($cultivationStatus))!='' ) {
             throw new Exception("Value must be an integer");
       }
       $this->cultivationStatus = $this->l_addslashes($cultivationStatus);
       $this->dirty = true;
   }
/*establishmentMeans*/
   public function getestablishmentMeans() {
       if ($this->establishmentMeans==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->establishmentMeans));
       }
   }
   public function setestablishmentMeans($establishmentMeans) {
       if (strlen($establishmentMeans) > omoccurrences::ESTABLISHMENTMEANS_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->establishmentMeans = $this->l_addslashes($establishmentMeans);
       $this->dirty = true;
   }
/*lifeStage*/
   public function getlifeStage() {
       if ($this->lifeStage==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->lifeStage));
       }
   }
   public function setlifeStage($lifeStage) {
       if (strlen($lifeStage) > omoccurrences::LIFESTAGE_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->lifeStage = $this->l_addslashes($lifeStage);
       $this->dirty = true;
   }
/*sex*/
   public function getsex() {
       if ($this->sex==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->sex));
       }
   }
   public function setsex($sex) {
       if (strlen($sex) > omoccurrences::SEX_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->sex = $this->l_addslashes($sex);
       $this->dirty = true;
   }
/*individualCount*/
   public function getindividualCount() {
       if ($this->individualCount==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->individualCount));
       }
   }
   public function setindividualCount($individualCount) {
       if (strlen($individualCount) > omoccurrences::INDIVIDUALCOUNT_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->individualCount = $this->l_addslashes($individualCount);
       $this->dirty = true;
   }
/*samplingProtocol*/
   public function getsamplingProtocol() {
       if ($this->samplingProtocol==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->samplingProtocol));
       }
   }
   public function setsamplingProtocol($samplingProtocol) {
       if (strlen($samplingProtocol) > omoccurrences::SAMPLINGPROTOCOL_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->samplingProtocol = $this->l_addslashes($samplingProtocol);
       $this->dirty = true;
   }
/*samplingEffort*/
   public function getsamplingEffort() {
       if ($this->samplingEffort==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->samplingEffort));
       }
   }
   public function setsamplingEffort($samplingEffort) {
       if (strlen($samplingEffort) > omoccurrences::SAMPLINGEFFORT_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->samplingEffort = $this->l_addslashes($samplingEffort);
       $this->dirty = true;
   }
/*preparations*/
   public function getpreparations() {
       if ($this->preparations==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->preparations));
       }
   }
   public function setpreparations($preparations) {
       if (strlen($preparations) > omoccurrences::PREPARATIONS_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->preparations = $this->l_addslashes($preparations);
       $this->dirty = true;
   }
/*locationID*/
   public function getlocationID() {
       if ($this->locationID==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->locationID));
       }
   }
   public function setlocationID($locationID) {
       if (strlen($locationID) > omoccurrences::LOCATIONID_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->locationID = $this->l_addslashes($locationID);
       $this->dirty = true;
   }
/*waterBody*/
   public function getwaterBody() {
       if ($this->waterBody==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->waterBody));
       }
   }
   public function setwaterBody($waterBody) {
       if (strlen($waterBody) > omoccurrences::WATERBODY_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->waterBody = $this->l_addslashes($waterBody);
       $this->dirty = true;
   }
/*country*/
   public function getcountry() {
       if ($this->country==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->country));
       }
   }
   public function setcountry($country) {
       if (strlen($country) > omoccurrences::COUNTRY_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->country = $this->l_addslashes($country);
       $this->dirty = true;
   }
/*stateProvince*/
   public function getstateProvince() {
       if ($this->stateProvince==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->stateProvince));
       }
   }
   public function setstateProvince($stateProvince) {
       if (strlen($stateProvince) > omoccurrences::STATEPROVINCE_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->stateProvince = $this->l_addslashes($stateProvince);
       $this->dirty = true;
   }
/*county*/
   public function getcounty() {
       if ($this->county==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->county));
       }
   }
   public function setcounty($county) {
       if (strlen($county) > omoccurrences::COUNTY_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->county = $this->l_addslashes($county);
       $this->dirty = true;
   }
/*municipality*/
   public function getmunicipality() {
       if ($this->municipality==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->municipality));
       }
   }
   public function setmunicipality($municipality) {
       if (strlen($municipality) > omoccurrences::MUNICIPALITY_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->municipality = $this->l_addslashes($municipality);
       $this->dirty = true;
   }
/*locality*/
   public function getlocality() {
       if ($this->locality==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->locality));
       }
   }
   public function setlocality($locality) {
       if (strlen($locality) > omoccurrences::LOCALITY_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->locality = $this->l_addslashes($locality);
       $this->dirty = true;
   }
/*localitySecurity*/
   public function getlocalitySecurity() {
       if ($this->localitySecurity==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->localitySecurity));
       }
   }
   public function setlocalitySecurity($localitySecurity) {
       if (strlen(preg_replace('/[^0-9]/','',$localitySecurity)) > omoccurrences::LOCALITYSECURITY_SIZE) { 
           throw new Exception('Value has too many digits for the field length.');
       } 
       $localitySecurity = trim($localitySecurity);
       if (!ctype_digit(strval($localitySecurity)) && trim(strval($localitySecurity))!='' ) {
             throw new Exception("Value must be an integer");
       }
       $this->localitySecurity = $this->l_addslashes($localitySecurity);
       $this->dirty = true;
   }
/*localitySecurityReason*/
   public function getlocalitySecurityReason() {
       if ($this->localitySecurityReason==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->localitySecurityReason));
       }
   }
   public function setlocalitySecurityReason($localitySecurityReason) {
       if (strlen($localitySecurityReason) > omoccurrences::LOCALITYSECURITYREASON_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->localitySecurityReason = $this->l_addslashes($localitySecurityReason);
       $this->dirty = true;
   }
/*decimalLatitude*/
   public function getdecimalLatitude() {
       if ($this->decimalLatitude==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->decimalLatitude));
       }
   }
   public function setdecimalLatitude($decimalLatitude) {
       if (strlen($decimalLatitude) > omoccurrences::DECIMALLATITUDE_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->decimalLatitude = $this->l_addslashes($decimalLatitude);
       $this->dirty = true;
   }
/*decimalLongitude*/
   public function getdecimalLongitude() {
       if ($this->decimalLongitude==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->decimalLongitude));
       }
   }
   public function setdecimalLongitude($decimalLongitude) {
       if (strlen($decimalLongitude) > omoccurrences::DECIMALLONGITUDE_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->decimalLongitude = $this->l_addslashes($decimalLongitude);
       $this->dirty = true;
   }
/*geodeticDatum*/
   public function getgeodeticDatum() {
       if ($this->geodeticDatum==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->geodeticDatum));
       }
   }
   public function setgeodeticDatum($geodeticDatum) {
       if (strlen($geodeticDatum) > omoccurrences::GEODETICDATUM_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->geodeticDatum = $this->l_addslashes($geodeticDatum);
       $this->dirty = true;
   }
/*coordinateUncertaintyInMeters*/
   public function getcoordinateUncertaintyInMeters() {
       if ($this->coordinateUncertaintyInMeters==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->coordinateUncertaintyInMeters));
       }
   }
   public function setcoordinateUncertaintyInMeters($coordinateUncertaintyInMeters) {
       if (strlen(preg_replace('/[^0-9]/','',$coordinateUncertaintyInMeters)) > omoccurrences::COORDINATEUNCERTAINTYINMETERS_SIZE) { 
           throw new Exception('Value has too many digits for the field length.');
       } 
       $coordinateUncertaintyInMeters = trim($coordinateUncertaintyInMeters);
       if (!ctype_digit(strval($coordinateUncertaintyInMeters)) && trim(strval($coordinateUncertaintyInMeters))!='' ) {
             throw new Exception("Value must be an integer");
       }
       $this->coordinateUncertaintyInMeters = $this->l_addslashes($coordinateUncertaintyInMeters);
       $this->dirty = true;
   }
/*footprintWKT*/
   public function getfootprintWKT() {
       if ($this->footprintWKT==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->footprintWKT));
       }
   }
   public function setfootprintWKT($footprintWKT) {
       if (strlen($footprintWKT) > omoccurrences::FOOTPRINTWKT_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->footprintWKT = $this->l_addslashes($footprintWKT);
       $this->dirty = true;
   }
/*coordinatePrecision*/
   public function getcoordinatePrecision() {
       if ($this->coordinatePrecision==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->coordinatePrecision));
       }
   }
   public function setcoordinatePrecision($coordinatePrecision) {
       if (strlen(preg_replace('/[^0-9]/','',$coordinatePrecision)) > omoccurrences::COORDINATEPRECISION_SIZE) { 
           throw new Exception('Value has too many digits for the field length.');
       } 
       $coordinatePrecision = trim($coordinatePrecision);
       if (!is_numeric($coordinatePrecision) && trim(strval($coordinatePrecision))!='' ) {
             throw new Exception("Value must be a number");
       }
       $this->coordinatePrecision = $this->l_addslashes($coordinatePrecision);
       $this->dirty = true;
   }
/*locationRemarks*/
   public function getlocationRemarks() {
       if ($this->locationRemarks==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->locationRemarks));
       }
   }
   public function setlocationRemarks($locationRemarks) {
       if (strlen($locationRemarks) > omoccurrences::LOCATIONREMARKS_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->locationRemarks = $this->l_addslashes($locationRemarks);
       $this->dirty = true;
   }
/*verbatimCoordinates*/
   public function getverbatimCoordinates() {
       if ($this->verbatimCoordinates==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->verbatimCoordinates));
       }
   }
   public function setverbatimCoordinates($verbatimCoordinates) {
       if (strlen($verbatimCoordinates) > omoccurrences::VERBATIMCOORDINATES_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->verbatimCoordinates = $this->l_addslashes($verbatimCoordinates);
       $this->dirty = true;
   }
/*verbatimCoordinateSystem*/
   public function getverbatimCoordinateSystem() {
       if ($this->verbatimCoordinateSystem==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->verbatimCoordinateSystem));
       }
   }
   public function setverbatimCoordinateSystem($verbatimCoordinateSystem) {
       if (strlen($verbatimCoordinateSystem) > omoccurrences::VERBATIMCOORDINATESYSTEM_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->verbatimCoordinateSystem = $this->l_addslashes($verbatimCoordinateSystem);
       $this->dirty = true;
   }
/*georeferencedBy*/
   public function getgeoreferencedBy() {
       if ($this->georeferencedBy==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->georeferencedBy));
       }
   }
   public function setgeoreferencedBy($georeferencedBy) {
       if (strlen($georeferencedBy) > omoccurrences::GEOREFERENCEDBY_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->georeferencedBy = $this->l_addslashes($georeferencedBy);
       $this->dirty = true;
   }
/*georeferenceProtocol*/
   public function getgeoreferenceProtocol() {
       if ($this->georeferenceProtocol==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->georeferenceProtocol));
       }
   }
   public function setgeoreferenceProtocol($georeferenceProtocol) {
       if (strlen($georeferenceProtocol) > omoccurrences::GEOREFERENCEPROTOCOL_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->georeferenceProtocol = $this->l_addslashes($georeferenceProtocol);
       $this->dirty = true;
   }
/*georeferenceSources*/
   public function getgeoreferenceSources() {
       if ($this->georeferenceSources==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->georeferenceSources));
       }
   }
   public function setgeoreferenceSources($georeferenceSources) {
       if (strlen($georeferenceSources) > omoccurrences::GEOREFERENCESOURCES_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->georeferenceSources = $this->l_addslashes($georeferenceSources);
       $this->dirty = true;
   }
/*georeferenceVerificationStatus*/
   public function getgeoreferenceVerificationStatus() {
       if ($this->georeferenceVerificationStatus==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->georeferenceVerificationStatus));
       }
   }
   public function setgeoreferenceVerificationStatus($georeferenceVerificationStatus) {
       if (strlen($georeferenceVerificationStatus) > omoccurrences::GEOREFERENCEVERIFICATIONSTATUS_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->georeferenceVerificationStatus = $this->l_addslashes($georeferenceVerificationStatus);
       $this->dirty = true;
   }
/*georeferenceRemarks*/
   public function getgeoreferenceRemarks() {
       if ($this->georeferenceRemarks==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->georeferenceRemarks));
       }
   }
   public function setgeoreferenceRemarks($georeferenceRemarks) {
       if (strlen($georeferenceRemarks) > omoccurrences::GEOREFERENCEREMARKS_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->georeferenceRemarks = $this->l_addslashes($georeferenceRemarks);
       $this->dirty = true;
   }
/*minimumElevationInMeters*/
   public function getminimumElevationInMeters() {
       if ($this->minimumElevationInMeters==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->minimumElevationInMeters));
       }
   }
   public function setminimumElevationInMeters($minimumElevationInMeters) {
       if (strlen(preg_replace('/[^0-9]/','',$minimumElevationInMeters)) > omoccurrences::MINIMUMELEVATIONINMETERS_SIZE) { 
           throw new Exception('Value has too many digits for the field length.');
       } 
       $minimumElevationInMeters = trim($minimumElevationInMeters);
       if (!ctype_digit(strval($minimumElevationInMeters)) && trim(strval($minimumElevationInMeters))!='' ) {
             throw new Exception("Value must be an integer");
       }
       $this->minimumElevationInMeters = $this->l_addslashes($minimumElevationInMeters);
       $this->dirty = true;
   }
/*maximumElevationInMeters*/
   public function getmaximumElevationInMeters() {
       if ($this->maximumElevationInMeters==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->maximumElevationInMeters));
       }
   }
   public function setmaximumElevationInMeters($maximumElevationInMeters) {
       if (strlen(preg_replace('/[^0-9]/','',$maximumElevationInMeters)) > omoccurrences::MAXIMUMELEVATIONINMETERS_SIZE) { 
           throw new Exception('Value has too many digits for the field length.');
       } 
       $maximumElevationInMeters = trim($maximumElevationInMeters);
       if (!ctype_digit(strval($maximumElevationInMeters)) && trim(strval($maximumElevationInMeters))!='' ) {
             throw new Exception("Value must be an integer");
       }
       $this->maximumElevationInMeters = $this->l_addslashes($maximumElevationInMeters);
       $this->dirty = true;
   }
/*verbatimElevation*/
   public function getverbatimElevation() {
       if ($this->verbatimElevation==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->verbatimElevation));
       }
   }
   public function setverbatimElevation($verbatimElevation) {
       if (strlen($verbatimElevation) > omoccurrences::VERBATIMELEVATION_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->verbatimElevation = $this->l_addslashes($verbatimElevation);
       $this->dirty = true;
   }
/*previousIdentifications*/
   public function getpreviousIdentifications() {
       if ($this->previousIdentifications==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->previousIdentifications));
       }
   }
   public function setpreviousIdentifications($previousIdentifications) {
       if (strlen($previousIdentifications) > omoccurrences::PREVIOUSIDENTIFICATIONS_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->previousIdentifications = $this->l_addslashes($previousIdentifications);
       $this->dirty = true;
   }
/*disposition*/
   public function getdisposition() {
       if ($this->disposition==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->disposition));
       }
   }
   public function setdisposition($disposition) {
       if (strlen($disposition) > omoccurrences::DISPOSITION_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->disposition = $this->l_addslashes($disposition);
       $this->dirty = true;
   }
/*genericcolumn1*/
   public function getgenericcolumn1() {
       if ($this->genericcolumn1==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->genericcolumn1));
       }
   }
   public function setgenericcolumn1($genericcolumn1) {
       if (strlen($genericcolumn1) > omoccurrences::GENERICCOLUMN1_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->genericcolumn1 = $this->l_addslashes($genericcolumn1);
       $this->dirty = true;
   }
/*genericcolumn2*/
   public function getgenericcolumn2() {
       if ($this->genericcolumn2==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->genericcolumn2));
       }
   }
   public function setgenericcolumn2($genericcolumn2) {
       if (strlen($genericcolumn2) > omoccurrences::GENERICCOLUMN2_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->genericcolumn2 = $this->l_addslashes($genericcolumn2);
       $this->dirty = true;
   }
/*modified*/
   public function getmodified() {
       if ($this->modified==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->modified));
       }
   }
   public function setmodified($modified) {
       if (strlen($modified) > omoccurrences::MODIFIED_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->modified = $this->l_addslashes($modified);
       $this->dirty = true;
   }
/*language*/
   public function getlanguage() {
       if ($this->language==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->language));
       }
   }
   public function setlanguage($language) {
       if (strlen($language) > omoccurrences::LANGUAGE_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->language = $this->l_addslashes($language);
       $this->dirty = true;
   }
/*observeruid*/
   public function getobserveruid() {
       if ($this->observeruid==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->observeruid));
       }
   }
   public function setobserveruid($observeruid) {
       if (strlen($observeruid) > omoccurrences::OBSERVERUID_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->observeruid = $this->l_addslashes($observeruid);
       $this->dirty = true;
   }
/*processingstatus*/
   public function getprocessingstatus() {
       if ($this->processingstatus==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->processingstatus));
       }
   }
   public function setprocessingstatus($processingstatus) {
       if (strlen($processingstatus) > omoccurrences::PROCESSINGSTATUS_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->processingstatus = $this->l_addslashes($processingstatus);
       $this->dirty = true;
   }
/*recordEnteredBy*/
   public function getrecordEnteredBy() {
       if ($this->recordEnteredBy==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->recordEnteredBy));
       }
   }
   public function setrecordEnteredBy($recordEnteredBy) {
       if (strlen($recordEnteredBy) > omoccurrences::RECORDENTEREDBY_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->recordEnteredBy = $this->l_addslashes($recordEnteredBy);
       $this->dirty = true;
   }
/*duplicateQuantity*/
   public function getduplicateQuantity() {
       if ($this->duplicateQuantity==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->duplicateQuantity));
       }
   }
   public function setduplicateQuantity($duplicateQuantity) {
       if (strlen(preg_replace('/[^0-9]/','',$duplicateQuantity)) > omoccurrences::DUPLICATEQUANTITY_SIZE) { 
           throw new Exception('Value has too many digits for the field length.');
       } 
       $duplicateQuantity = trim($duplicateQuantity);
       if (!ctype_digit(strval($duplicateQuantity)) && trim(strval($duplicateQuantity))!='' ) {
             throw new Exception("Value must be an integer");
       }
       $this->duplicateQuantity = $this->l_addslashes($duplicateQuantity);
       $this->dirty = true;
   }
/*labelProject*/
   public function getlabelProject() {
       if ($this->labelProject==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->labelProject));
       }
   }
   public function setlabelProject($labelProject) {
       if (strlen($labelProject) > omoccurrences::LABELPROJECT_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->labelProject = $this->l_addslashes($labelProject);
       $this->dirty = true;
   }
/*dynamicFields*/
   public function getdynamicFields() {
       if ($this->dynamicFields==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->dynamicFields));
       }
   }
   public function setdynamicFields($dynamicFields) {
       if (strlen($dynamicFields) > omoccurrences::DYNAMICFIELDS_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->dynamicFields = $this->l_addslashes($dynamicFields);
       $this->dirty = true;
   }
/*dateEntered*/
   public function getdateEntered() {
       if ($this->dateEntered==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->dateEntered));
       }
   }
   public function setdateEntered($dateEntered) {
       if (strlen($dateEntered) > omoccurrences::DATEENTERED_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->dateEntered = $this->l_addslashes($dateEntered);
       $this->dirty = true;
   }
/*dateLastModified*/
   public function getdateLastModified() {
       if ($this->dateLastModified==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->dateLastModified));
       }
   }
   public function setdateLastModified($dateLastModified) {
       if (strlen($dateLastModified) > omoccurrences::DATELASTMODIFIED_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->dateLastModified = $this->l_addslashes($dateLastModified);
       $this->dirty = true;
   }

/*minimumDepthInMeters*/
   public function getminimumDepthInMeters() {
       if ($this->minimumDepthInMeters==null) {
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->minimumDepthInMeters));
       }
   }
   public function setminimumDepthInMeters($minimumDepthInMeters) {
       if (strlen($minimumDepthInMeters) > omoccurrences::MINIMUMDEPTHINMETERS_SIZE) {
           throw new Exception('Value exceeds field length.');
       }
       $this->minimumDepthInMeters = $this->l_addslashes($minimumDepthInMeters);
       $this->dirty = true;
   }
/*maximumDepthInMeters*/
   public function getmaximumDepthInMeters() {
       if ($this->maximumDepthInMeters==null) {
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->maximumDepthInMeters));
       }
   }
   public function setmaximumDepthInMeters($maximumDepthInMeters) {
       if (strlen($maximumDepthInMeters) > omoccurrences::MAXIMUMDEPTHINMETERS_SIZE) {
           throw new Exception('Value exceeds field length.');
       }
       $this->maximumDepthInMeters = $this->l_addslashes($maximumDepthInMeters);
       $this->dirty = true;
   }
/*verbatimDepth*/
   public function getverbatimDepth() {
       if ($this->verbatimDepth==null) {
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->verbatimDepth));
       }
   }
   public function setverbatimDepth($verbatimDepth) {
       if (strlen($verbatimDepth) > omoccurrences::VERBATIMDEPTH_SIZE) {
           throw new Exception('Value exceeds field length.');
       }
       $this->verbatimDepth = $this->l_addslashes($verbatimDepth);
       $this->dirty = true;
   }
/*storageLocation*/
   public function getstorageLocation() {
       if ($this->storageLocation==null) {
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->storageLocation));
       }
   }
   public function setstorageLocation($storageLocation) {
       if (strlen($storageLocation) > omoccurrences::STORAGELOCATION_SIZE) {
           throw new Exception('Value exceeds field length.');
       }
       $this->storageLocation = $this->l_addslashes($storageLocation);
       $this->dirty = true;
   }

/*taxonGuid*/
   public function gettaxonGuid() {
       // Note: Not stored to DB.
       if ($this->taxonGuid==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->taxonGuid));
       }
   }
   public function settaxonGuid($taxonGuid) {
       $this->taxonGuid = $this->l_addslashes($taxonGuid);
       // Note: Not stored to DB.
       // $this->dirty = true;
   }
/*fundingSource*/
   public function getfundingSource() {
       // Note: Not stored to DB.
       if ($this->fundingSource==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->fundingSource));
       }
   }
   public function setfundingSource($fundingSource) {
       $this->fundingSource = $this->l_addslashes($fundingSource);
       // Note: Not stored to DB.
       // $this->dirty = true;
   }
/*documentGuid*/
   public function getdocumentGuid() {
       // Note: Not stored to DB.
       if ($this->documentGuid==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->documentGuid));
       }
   }
   public function setdocumentGuid($documentGuid) {
       $this->documentGuid = $this->l_addslashes($documentGuid);
       // Note: Not stored to DB.
       // $this->dirty = true;
   }
/* collectorId */
   public function setcollectorid($collectorid) { 
      $this->collectorid = $collectorid;
      // Note: Not stored to DB.
      // $this->dirty = true;
   } 
/*documentDate*/
   public function getdocumentDate() {
       // Note: Not stored to DB.
       if ($this->documentDate==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->documentDate));
       }
   }
   public function setdocumentDate($documentDate) {
       $this->documentDate = $this->l_addslashes($documentDate);
       // Note: Not stored to DB.
       // $this->dirty = true;
   }

   public function PK() { // get value of primary key 
        $returnvalue = '';
        $returnvalue .= $this->getoccid();
        return $returnvalue;
   }
   public function PKArray() { // get name and value of primary key fields 
        $returnvalue = array();
        $returnvalue['occid'] = $this->getoccid();
        return $returnvalue;
   }
   public function NumberOfPrimaryKeyFields() { // returns the number of primary key fields defined for this table 
        return 1;
   }

   // Constants holding the mysqli field type character (s,i,d) for each field
  const C_occidMYSQLI_TYPE = 'i';
  const C_collidMYSQLI_TYPE = 'i';
  const C_dbpkMYSQLI_TYPE = 's';
  const C_basisOfRecordMYSQLI_TYPE = 's';
  const C_occurrenceIDMYSQLI_TYPE = 's';
  const C_catalogNumberMYSQLI_TYPE = 's';
  const C_otherCatalogNumbersMYSQLI_TYPE = 's';
  const C_ownerInstitutionCodeMYSQLI_TYPE = 's';
  const C_institutionIDMYSQLI_TYPE = 's';
  const C_collectionIDMYSQLI_TYPE = 's';
  const C_datasetIDMYSQLI_TYPE = 's';
  const C_institutionCodeMYSQLI_TYPE = 's';
  const C_collectionCodeMYSQLI_TYPE = 's';
  const C_familyMYSQLI_TYPE = 's';
  const C_scientificNameMYSQLI_TYPE = 's';
  const C_scinameMYSQLI_TYPE = 's';
  const C_tidinterpretedMYSQLI_TYPE = 'i';
  const C_genusMYSQLI_TYPE = 's';
  const C_specificEpithetMYSQLI_TYPE = 's';
  const C_taxonRankMYSQLI_TYPE = 's';
  const C_infraspecificEpithetMYSQLI_TYPE = 's';
  const C_scientificNameAuthorshipMYSQLI_TYPE = 's';
  const C_taxonRemarksMYSQLI_TYPE = 's';
  const C_identifiedByMYSQLI_TYPE = 's';
  const C_dateIdentifiedMYSQLI_TYPE = 's';
  const C_identificationReferencesMYSQLI_TYPE = 's';
  const C_identificationRemarksMYSQLI_TYPE = 's';
  const C_identificationQualifierMYSQLI_TYPE = 's';
  const C_typeStatusMYSQLI_TYPE = 's';
  const C_recordedByMYSQLI_TYPE = 's';
  const C_recordNumberMYSQLI_TYPE = 's';
  const C_recordedByIdMYSQLI_TYPE = 's';
  const C_associatedCollectorsMYSQLI_TYPE = 's';
  const C_eventDateMYSQLI_TYPE = 's';
  const C_latestDateCollectedMYSQLI_TYPE = 'd';
  const C_yearMYSQLI_TYPE = 'i';
  const C_monthMYSQLI_TYPE = 'i';
  const C_dayMYSQLI_TYPE = 'i';
  const C_startDayOfYearMYSQLI_TYPE = 'i';
  const C_endDayOfYearMYSQLI_TYPE = 'i';
  const C_verbatimEventDateMYSQLI_TYPE = 's';
  const C_habitatMYSQLI_TYPE = 's';
  const C_substrateMYSQLI_TYPE = 's';
  const C_fieldNotesMYSQLI_TYPE = 's';
  const C_fieldnumberMYSQLI_TYPE = 's';
  const C_eventIDMYSQLI_TYPE = 's';
  const C_occurrenceRemarksMYSQLI_TYPE = 's';
  const C_informationWithheldMYSQLI_TYPE = 's';
  const C_dataGeneralizationsMYSQLI_TYPE = 's';
  const C_associatedOccurrencesMYSQLI_TYPE = 's';
  const C_associatedTaxaMYSQLI_TYPE = 's';
  const C_dynamicPropertiesMYSQLI_TYPE = 's';
  const C_verbatimAttributesMYSQLI_TYPE = 's';
  const C_behaviorMYSQLI_TYPE = 's';
  const C_reproductiveConditionMYSQLI_TYPE = 's';
  const C_cultivationStatusMYSQLI_TYPE = 'i';
  const C_establishmentMeansMYSQLI_TYPE = 's';
  const C_lifeStageMYSQLI_TYPE = 's';
  const C_sexMYSQLI_TYPE = 's';
  const C_individualCountMYSQLI_TYPE = 's';
  const C_samplingProtocolMYSQLI_TYPE = 's';
  const C_samplingEffortMYSQLI_TYPE = 's';
  const C_preparationsMYSQLI_TYPE = 's';
  const C_locationIDMYSQLI_TYPE = 's';
  const C_waterBodyMYSQLI_TYPE = 's';
  const C_countryMYSQLI_TYPE = 's';
  const C_stateProvinceMYSQLI_TYPE = 's';
  const C_countyMYSQLI_TYPE = 's';
  const C_municipalityMYSQLI_TYPE = 's';
  const C_localityMYSQLI_TYPE = 's';
  const C_localitySecurityMYSQLI_TYPE = 'i';
  const C_localitySecurityReasonMYSQLI_TYPE = 's';
  const C_decimalLatitudeMYSQLI_TYPE = 'd';
  const C_decimalLongitudeMYSQLI_TYPE = 'd';
  const C_geodeticDatumMYSQLI_TYPE = 's';
  const C_coordinateUncertaintyInMetersMYSQLI_TYPE = 'i';
  const C_footprintWKTMYSQLI_TYPE = 's';
  const C_coordinatePrecisionMYSQLI_TYPE = 'd';
  const C_locationRemarksMYSQLI_TYPE = 's';
  const C_verbatimCoordinatesMYSQLI_TYPE = 's';
  const C_verbatimCoordinateSystemMYSQLI_TYPE = 's';
  const C_georeferencedByMYSQLI_TYPE = 's';
  const C_georeferenceProtocolMYSQLI_TYPE = 's';
  const C_georeferenceSourcesMYSQLI_TYPE = 's';
  const C_georeferenceVerificationStatusMYSQLI_TYPE = 's';
  const C_georeferenceRemarksMYSQLI_TYPE = 's';
  const C_minimumElevationInMetersMYSQLI_TYPE = 'i';
  const C_maximumElevationInMetersMYSQLI_TYPE = 'i';
  const C_verbatimElevationMYSQLI_TYPE = 's';
  const C_previousIdentificationsMYSQLI_TYPE = 's';
  const C_dispositionMYSQLI_TYPE = 's';
  const C_genericcolumn1MYSQLI_TYPE = 's';
  const C_genericcolumn2MYSQLI_TYPE = 's';
  const C_modifiedMYSQLI_TYPE = 's';
  const C_languageMYSQLI_TYPE = 's';
  const C_observeruidMYSQLI_TYPE = 'i';
  const C_processingstatusMYSQLI_TYPE = 's';
  const C_recordEnteredByMYSQLI_TYPE = 's';
  const C_duplicateQuantityMYSQLI_TYPE = 'i';
  const C_labelProjectMYSQLI_TYPE = 's';
  const C_dynamicFieldsMYSQLI_TYPE = 's';
  const C_dateEnteredMYSQLI_TYPE = 's';
  const C_dateLastModifiedMYSQLI_TYPE = 's';
  const C_minimumDepthInMetersMYSQLI_TYPE='i';
  const C_maximumDepthInMetersMYSQLI_TYPE='i';
  const C_verbatimDepthMYSQLI_TYPE='s';
  const C_storageLocationMYSQLI_TYPE='s';

   // function to obtain the mysqli field type character from a fieldname
   public function MySQLiFieldType($aFieldname) { 
      $retval = '';
      if ($aFieldname=='occid') { $retval = self::C_occidMYSQLI_TYPE; }
      if ($aFieldname=='collid') { $retval = self::C_collidMYSQLI_TYPE; }
      if ($aFieldname=='dbpk') { $retval = self::C_dbpkMYSQLI_TYPE; }
      if ($aFieldname=='basisOfRecord') { $retval = self::C_basisOfRecordMYSQLI_TYPE; }
      if ($aFieldname=='occurrenceID') { $retval = self::C_occurrenceIDMYSQLI_TYPE; }
      if ($aFieldname=='catalogNumber') { $retval = self::C_catalogNumberMYSQLI_TYPE; }
      if ($aFieldname=='otherCatalogNumbers') { $retval = self::C_otherCatalogNumbersMYSQLI_TYPE; }
      if ($aFieldname=='ownerInstitutionCode') { $retval = self::C_ownerInstitutionCodeMYSQLI_TYPE; }
      if ($aFieldname=='institutionID') { $retval = self::C_institutionIDMYSQLI_TYPE; }
      if ($aFieldname=='collectionID') { $retval = self::C_collectionIDMYSQLI_TYPE; }
      if ($aFieldname=='datasetID') { $retval = self::C_datasetIDMYSQLI_TYPE; }
      if ($aFieldname=='institutionCode') { $retval = self::C_institutionCodeMYSQLI_TYPE; }
      if ($aFieldname=='collectionCode') { $retval = self::C_collectionCodeMYSQLI_TYPE; }
      if ($aFieldname=='family') { $retval = self::C_familyMYSQLI_TYPE; }
      if ($aFieldname=='scientificName') { $retval = self::C_scientificNameMYSQLI_TYPE; }
      if ($aFieldname=='sciname') { $retval = self::C_scinameMYSQLI_TYPE; }
      if ($aFieldname=='tidinterpreted') { $retval = self::C_tidinterpretedMYSQLI_TYPE; }
      if ($aFieldname=='genus') { $retval = self::C_genusMYSQLI_TYPE; }
      if ($aFieldname=='specificEpithet') { $retval = self::C_specificEpithetMYSQLI_TYPE; }
      if ($aFieldname=='taxonRank') { $retval = self::C_taxonRankMYSQLI_TYPE; }
      if ($aFieldname=='infraspecificEpithet') { $retval = self::C_infraspecificEpithetMYSQLI_TYPE; }
      if ($aFieldname=='scientificNameAuthorship') { $retval = self::C_scientificNameAuthorshipMYSQLI_TYPE; }
      if ($aFieldname=='taxonRemarks') { $retval = self::C_taxonRemarksMYSQLI_TYPE; }
      if ($aFieldname=='identifiedBy') { $retval = self::C_identifiedByMYSQLI_TYPE; }
      if ($aFieldname=='dateIdentified') { $retval = self::C_dateIdentifiedMYSQLI_TYPE; }
      if ($aFieldname=='identificationReferences') { $retval = self::C_identificationReferencesMYSQLI_TYPE; }
      if ($aFieldname=='identificationRemarks') { $retval = self::C_identificationRemarksMYSQLI_TYPE; }
      if ($aFieldname=='identificationQualifier') { $retval = self::C_identificationQualifierMYSQLI_TYPE; }
      if ($aFieldname=='typeStatus') { $retval = self::C_typeStatusMYSQLI_TYPE; }
      if ($aFieldname=='recordedBy') { $retval = self::C_recordedByMYSQLI_TYPE; }
      if ($aFieldname=='recordNumber') { $retval = self::C_recordNumberMYSQLI_TYPE; }
      if ($aFieldname=='recordedById') { $retval = self::C_recordedByIdMYSQLI_TYPE; }
      if ($aFieldname=='associatedCollectors') { $retval = self::C_associatedCollectorsMYSQLI_TYPE; }
      if ($aFieldname=='eventDate') { $retval = self::C_eventDateMYSQLI_TYPE; }
      if ($aFieldname=='latestDateCollected') { $retval = self::C_latestDateCollectedMYSQLI_TYPE; }
      if ($aFieldname=='year') { $retval = self::C_yearMYSQLI_TYPE; }
      if ($aFieldname=='month') { $retval = self::C_monthMYSQLI_TYPE; }
      if ($aFieldname=='day') { $retval = self::C_dayMYSQLI_TYPE; }
      if ($aFieldname=='startDayOfYear') { $retval = self::C_startDayOfYearMYSQLI_TYPE; }
      if ($aFieldname=='endDayOfYear') { $retval = self::C_endDayOfYearMYSQLI_TYPE; }
      if ($aFieldname=='verbatimEventDate') { $retval = self::C_verbatimEventDateMYSQLI_TYPE; }
      if ($aFieldname=='habitat') { $retval = self::C_habitatMYSQLI_TYPE; }
      if ($aFieldname=='substrate') { $retval = self::C_substrateMYSQLI_TYPE; }
      if ($aFieldname=='fieldNotes') { $retval = self::C_fieldNotesMYSQLI_TYPE; }
      if ($aFieldname=='fieldnumber') { $retval = self::C_fieldnumberMYSQLI_TYPE; }
      if ($aFieldname=='eventID') { $retval = self::C_eventIDMYSQLI_TYPE; }
      if ($aFieldname=='occurrenceRemarks') { $retval = self::C_occurrenceRemarksMYSQLI_TYPE; }
      if ($aFieldname=='informationWithheld') { $retval = self::C_informationWithheldMYSQLI_TYPE; }
      if ($aFieldname=='dataGeneralizations') { $retval = self::C_dataGeneralizationsMYSQLI_TYPE; }
      if ($aFieldname=='associatedOccurrences') { $retval = self::C_associatedOccurrencesMYSQLI_TYPE; }
      if ($aFieldname=='associatedTaxa') { $retval = self::C_associatedTaxaMYSQLI_TYPE; }
      if ($aFieldname=='dynamicProperties') { $retval = self::C_dynamicPropertiesMYSQLI_TYPE; }
      if ($aFieldname=='verbatimAttributes') { $retval = self::C_verbatimAttributesMYSQLI_TYPE; }
      if ($aFieldname=='behavior') { $retval = self::C_behaviorMYSQLI_TYPE; }
      if ($aFieldname=='reproductiveCondition') { $retval = self::C_reproductiveConditionMYSQLI_TYPE; }
      if ($aFieldname=='cultivationStatus') { $retval = self::C_cultivationStatusMYSQLI_TYPE; }
      if ($aFieldname=='establishmentMeans') { $retval = self::C_establishmentMeansMYSQLI_TYPE; }
      if ($aFieldname=='lifeStage') { $retval = self::C_lifeStageMYSQLI_TYPE; }
      if ($aFieldname=='sex') { $retval = self::C_sexMYSQLI_TYPE; }
      if ($aFieldname=='individualCount') { $retval = self::C_individualCountMYSQLI_TYPE; }
      if ($aFieldname=='samplingProtocol') { $retval = self::C_samplingProtocolMYSQLI_TYPE; }
      if ($aFieldname=='samplingEffort') { $retval = self::C_samplingEffortMYSQLI_TYPE; }
      if ($aFieldname=='preparations') { $retval = self::C_preparationsMYSQLI_TYPE; }
      if ($aFieldname=='locationID') { $retval = self::C_locationIDMYSQLI_TYPE; }
      if ($aFieldname=='waterBody') { $retval = self::C_waterBodyMYSQLI_TYPE; }
      if ($aFieldname=='country') { $retval = self::C_countryMYSQLI_TYPE; }
      if ($aFieldname=='stateProvince') { $retval = self::C_stateProvinceMYSQLI_TYPE; }
      if ($aFieldname=='county') { $retval = self::C_countyMYSQLI_TYPE; }
      if ($aFieldname=='municipality') { $retval = self::C_municipalityMYSQLI_TYPE; }
      if ($aFieldname=='locality') { $retval = self::C_localityMYSQLI_TYPE; }
      if ($aFieldname=='localitySecurity') { $retval = self::C_localitySecurityMYSQLI_TYPE; }
      if ($aFieldname=='localitySecurityReason') { $retval = self::C_localitySecurityReasonMYSQLI_TYPE; }
      if ($aFieldname=='decimalLatitude') { $retval = self::C_decimalLatitudeMYSQLI_TYPE; }
      if ($aFieldname=='decimalLongitude') { $retval = self::C_decimalLongitudeMYSQLI_TYPE; }
      if ($aFieldname=='geodeticDatum') { $retval = self::C_geodeticDatumMYSQLI_TYPE; }
      if ($aFieldname=='coordinateUncertaintyInMeters') { $retval = self::C_coordinateUncertaintyInMetersMYSQLI_TYPE; }
      if ($aFieldname=='footprintWKT') { $retval = self::C_footprintWKTMYSQLI_TYPE; }
      if ($aFieldname=='coordinatePrecision') { $retval = self::C_coordinatePrecisionMYSQLI_TYPE; }
      if ($aFieldname=='locationRemarks') { $retval = self::C_locationRemarksMYSQLI_TYPE; }
      if ($aFieldname=='verbatimCoordinates') { $retval = self::C_verbatimCoordinatesMYSQLI_TYPE; }
      if ($aFieldname=='verbatimCoordinateSystem') { $retval = self::C_verbatimCoordinateSystemMYSQLI_TYPE; }
      if ($aFieldname=='georeferencedBy') { $retval = self::C_georeferencedByMYSQLI_TYPE; }
      if ($aFieldname=='georeferenceProtocol') { $retval = self::C_georeferenceProtocolMYSQLI_TYPE; }
      if ($aFieldname=='georeferenceSources') { $retval = self::C_georeferenceSourcesMYSQLI_TYPE; }
      if ($aFieldname=='georeferenceVerificationStatus') { $retval = self::C_georeferenceVerificationStatusMYSQLI_TYPE; }
      if ($aFieldname=='georeferenceRemarks') { $retval = self::C_georeferenceRemarksMYSQLI_TYPE; }
      if ($aFieldname=='minimumElevationInMeters') { $retval = self::C_minimumElevationInMetersMYSQLI_TYPE; }
      if ($aFieldname=='maximumElevationInMeters') { $retval = self::C_maximumElevationInMetersMYSQLI_TYPE; }
      if ($aFieldname=='verbatimElevation') { $retval = self::C_verbatimElevationMYSQLI_TYPE; }
      if ($aFieldname=='previousIdentifications') { $retval = self::C_previousIdentificationsMYSQLI_TYPE; }
      if ($aFieldname=='disposition') { $retval = self::C_dispositionMYSQLI_TYPE; }
      if ($aFieldname=='genericcolumn1') { $retval = self::C_genericcolumn1MYSQLI_TYPE; }
      if ($aFieldname=='genericcolumn2') { $retval = self::C_genericcolumn2MYSQLI_TYPE; }
      if ($aFieldname=='modified') { $retval = self::C_modifiedMYSQLI_TYPE; }
      if ($aFieldname=='language') { $retval = self::C_languageMYSQLI_TYPE; }
      if ($aFieldname=='observeruid') { $retval = self::C_observeruidMYSQLI_TYPE; }
      if ($aFieldname=='processingstatus') { $retval = self::C_processingstatusMYSQLI_TYPE; }
      if ($aFieldname=='recordEnteredBy') { $retval = self::C_recordEnteredByMYSQLI_TYPE; }
      if ($aFieldname=='duplicateQuantity') { $retval = self::C_duplicateQuantityMYSQLI_TYPE; }
      if ($aFieldname=='labelProject') { $retval = self::C_labelProjectMYSQLI_TYPE; }
      if ($aFieldname=='dynamicFields') { $retval = self::C_dynamicFieldsMYSQLI_TYPE; }
      if ($aFieldname=='dateEntered') { $retval = self::C_dateEnteredMYSQLI_TYPE; }
      if ($aFieldname=='dateLastModified') { $retval = self::C_dateLastModifiedMYSQLI_TYPE; }
      if ($aFieldname=='minimumDepthInMeters') { $retval = self::C_minimumDepthInMetersMYSQLI_TYPE; } 
      if ($aFieldname=='maximumDepthInMeters') { $retval = self::C_maximumDepthInMetersMYSQLI_TYPE; } 
      if ($aFieldname=='verbatimDepth') { $retval = self::C_verbatimDepthMYSQLI_TYPE; } 
      if ($aFieldname=='storageLocation') { $retval = self::C_storageLocationMYSQLI_TYPE; }
      return $retval;
   }

   // Function load() can take either the value of the primary key which uniquely identifies a particular row
   // or an array of array('primarykeyfieldname'=>'value') in the case of a single field primary key
   // or an array of fieldname value pairs in the case of multiple field primary key.
   public function load($pk) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = false;
        try {
             if (is_array($pk)) { 
                 $this->setoccid($pk[occid]);
             } else { ;
                 $this->setoccid($pk);
             };
        } 
        catch (Exception $e) { 
             throw new Exception($e->getMessage());
        }
        if($this->occid != NULL) {
           $preparesql = 'SELECT occid, collid, dbpk, basisOfRecord, occurrenceID, catalogNumber, otherCatalogNumbers, ownerInstitutionCode, institutionID, collectionID, datasetID, institutionCode, collectionCode, family, scientificName, sciname, tidinterpreted, genus, specificEpithet, taxonRank, infraspecificEpithet, scientificNameAuthorship, taxonRemarks, identifiedBy, dateIdentified, identificationReferences, identificationRemarks, identificationQualifier, typeStatus, recordedBy, recordNumber, recordedById, associatedCollectors, eventDate, latestDateCollected, year, month, day, startDayOfYear, endDayOfYear, verbatimEventDate, habitat, substrate, fieldNotes, fieldnumber, eventID, occurrenceRemarks, informationWithheld, dataGeneralizations, associatedOccurrences, associatedTaxa, dynamicProperties, verbatimAttributes, behavior, reproductiveCondition, cultivationStatus, establishmentMeans, lifeStage, sex, individualCount, samplingProtocol, samplingEffort, preparations, locationID, waterBody, country, stateProvince, county, municipality, locality, localitySecurity, localitySecurityReason, decimalLatitude, decimalLongitude, geodeticDatum, coordinateUncertaintyInMeters, footprintWKT, coordinatePrecision, locationRemarks, verbatimCoordinates, verbatimCoordinateSystem, georeferencedBy, georeferenceProtocol, georeferenceSources, georeferenceVerificationStatus, georeferenceRemarks, minimumElevationInMeters, maximumElevationInMeters, verbatimElevation, previousIdentifications, disposition, genericcolumn1, genericcolumn2, modified, language, observeruid, processingstatus, recordEnteredBy, duplicateQuantity, labelProject, dynamicFields, dateEntered, dateLastModified, minimumDepthInMeters, maximumDepthInMeters, verbatimDepth, storageLocation FROM omoccurrences WHERE occid = ? ';

           if ($statement = $connection->prepare($preparesql)) { 
              $statement->bind_param("i", $this->occid);
              $statement->execute();
              $statement->bind_result($this->occid, $this->collid, $this->dbpk, $this->basisOfRecord, $this->occurrenceID, $this->catalogNumber, $this->otherCatalogNumbers, $this->ownerInstitutionCode, $this->institutionID, $this->collectionID, $this->datasetID, $this->institutionCode, $this->collectionCode, $this->family, $this->scientificName, $this->sciname, $this->tidinterpreted, $this->genus, $this->specificEpithet, $this->taxonRank, $this->infraspecificEpithet, $this->scientificNameAuthorship, $this->taxonRemarks, $this->identifiedBy, $this->dateIdentified, $this->identificationReferences, $this->identificationRemarks, $this->identificationQualifier, $this->typeStatus, $this->recordedBy, $this->recordNumber, $this->recordedById, $this->associatedCollectors, $this->eventDate, $this->latestDateCollected, $this->year, $this->month, $this->day, $this->startDayOfYear, $this->endDayOfYear, $this->verbatimEventDate, $this->habitat, $this->substrate, $this->fieldNotes, $this->fieldnumber, $this->eventID, $this->occurrenceRemarks, $this->informationWithheld, $this->dataGeneralizations, $this->associatedOccurrences, $this->associatedTaxa, $this->dynamicProperties, $this->verbatimAttributes, $this->behavior, $this->reproductiveCondition, $this->cultivationStatus, $this->establishmentMeans, $this->lifeStage, $this->sex, $this->individualCount, $this->samplingProtocol, $this->samplingEffort, $this->preparations, $this->locationID, $this->waterBody, $this->country, $this->stateProvince, $this->county, $this->municipality, $this->locality, $this->localitySecurity, $this->localitySecurityReason, $this->decimalLatitude, $this->decimalLongitude, $this->geodeticDatum, $this->coordinateUncertaintyInMeters, $this->footprintWKT, $this->coordinatePrecision, $this->locationRemarks, $this->verbatimCoordinates, $this->verbatimCoordinateSystem, $this->georeferencedBy, $this->georeferenceProtocol, $this->georeferenceSources, $this->georeferenceVerificationStatus, $this->georeferenceRemarks, $this->minimumElevationInMeters, $this->maximumElevationInMeters, $this->verbatimElevation, $this->previousIdentifications, $this->disposition, $this->genericcolumn1, $this->genericcolumn2, $this->modified, $this->language, $this->observeruid, $this->processingstatus, $this->recordEnteredBy, $this->duplicateQuantity, $this->labelProject, $this->dynamicFields, $this->dateEntered, $this->dateLastModified, $this->minimumDepthInMeters, $this->maximumDepthInMeters, $this->verbatimDepth, $this->storageLocation);
              $statement->fetch();
              $statement->close();
           }

            $this->loaded = true;
            $this->dirty = false;
        } else { 
        }
        return $returnvalue;
    }
   //---------------------------------------------------------------------------

   // Function save() will either save the current record or insert a new record.
   // Inserts new record if the primary key field in this table is null 
   // for this instance of this object.
   // Otherwise updates the record identified by the primary key value.
   public function save() {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = false;
        // Test to see if this is an insert or update.
        if ($this->occid!= NULL) {
            $sql  = 'UPDATE  omoccurrences SET ';
            $isInsert = false;
            $sql .=  "  collid = ? ";
            $sql .=  ", dbpk = ? ";
            $sql .=  ", basisOfRecord = ? ";
            $sql .=  ", occurrenceID = ? ";
            $sql .=  ", catalogNumber = ? ";
            $sql .=  ", otherCatalogNumbers = ? ";
            $sql .=  ", ownerInstitutionCode = ? ";
            $sql .=  ", institutionID = ? ";
            $sql .=  ", collectionID = ? ";
            $sql .=  ", datasetID = ? ";
            $sql .=  ", institutionCode = ? ";
            $sql .=  ", collectionCode = ? ";
            $sql .=  ", family = ? ";
            $sql .=  ", scientificName = ? ";
            $sql .=  ", sciname = ? ";
            $sql .=  ", tidinterpreted = ? ";
            $sql .=  ", genus = ? ";
            $sql .=  ", specificEpithet = ? ";
            $sql .=  ", taxonRank = ? ";
            $sql .=  ", infraspecificEpithet = ? ";
            $sql .=  ", scientificNameAuthorship = ? ";
            $sql .=  ", taxonRemarks = ? ";
            $sql .=  ", identifiedBy = ? ";
            $sql .=  ", dateIdentified = ? ";
            $sql .=  ", identificationReferences = ? ";
            $sql .=  ", identificationRemarks = ? ";
            $sql .=  ", identificationQualifier = ? ";
            $sql .=  ", typeStatus = ? ";
            $sql .=  ", recordedBy = ? ";
            $sql .=  ", recordNumber = ? ";
            $sql .=  ", recordedById = ? ";
            $sql .=  ", associatedCollectors = ? ";
            $sql .=  ", eventDate = ? ";
            $sql .=  ", latestDateCollected = ? ";
            $sql .=  ", year = ? ";
            $sql .=  ", month = ? ";
            $sql .=  ", day = ? ";
            $sql .=  ", startDayOfYear = ? ";
            $sql .=  ", endDayOfYear = ? ";
            $sql .=  ", verbatimEventDate = ? ";
            $sql .=  ", habitat = ? ";
            $sql .=  ", substrate = ? ";
            $sql .=  ", fieldNotes = ? ";
            $sql .=  ", fieldnumber = ? ";
            $sql .=  ", eventID = ? ";
            $sql .=  ", occurrenceRemarks = ? ";
            $sql .=  ", informationWithheld = ? ";
            $sql .=  ", dataGeneralizations = ? ";
            $sql .=  ", associatedOccurrences = ? ";
            $sql .=  ", associatedTaxa = ? ";
            $sql .=  ", dynamicProperties = ? ";
            $sql .=  ", verbatimAttributes = ? ";
            $sql .=  ", behavior = ? ";
            $sql .=  ", reproductiveCondition = ? ";
            $sql .=  ", cultivationStatus = ? ";
            $sql .=  ", establishmentMeans = ? ";
            $sql .=  ", lifeStage = ? ";
            $sql .=  ", sex = ? ";
            $sql .=  ", individualCount = ? ";
            $sql .=  ", samplingProtocol = ? ";
            $sql .=  ", samplingEffort = ? ";
            $sql .=  ", preparations = ? ";
            $sql .=  ", locationID = ? ";
            $sql .=  ", waterBody = ? ";
            $sql .=  ", country = ? ";
            $sql .=  ", stateProvince = ? ";
            $sql .=  ", county = ? ";
            $sql .=  ", municipality = ? ";
            $sql .=  ", locality = ? ";
            $sql .=  ", localitySecurity = ? ";
            $sql .=  ", localitySecurityReason = ? ";
            $sql .=  ", decimalLatitude = ? ";
            $sql .=  ", decimalLongitude = ? ";
            $sql .=  ", geodeticDatum = ? ";
            $sql .=  ", coordinateUncertaintyInMeters = ? ";
            $sql .=  ", footprintWKT = ? ";
            $sql .=  ", coordinatePrecision = ? ";
            $sql .=  ", locationRemarks = ? ";
            $sql .=  ", verbatimCoordinates = ? ";
            $sql .=  ", verbatimCoordinateSystem = ? ";
            $sql .=  ", georeferencedBy = ? ";
            $sql .=  ", georeferenceProtocol = ? ";
            $sql .=  ", georeferenceSources = ? ";
            $sql .=  ", georeferenceVerificationStatus = ? ";
            $sql .=  ", georeferenceRemarks = ? ";
            $sql .=  ", minimumElevationInMeters = ? ";
            $sql .=  ", maximumElevationInMeters = ? ";
            $sql .=  ", verbatimElevation = ? ";
            $sql .=  ", previousIdentifications = ? ";
            $sql .=  ", disposition = ? ";
            $sql .=  ", genericcolumn1 = ? ";
            $sql .=  ", genericcolumn2 = ? ";
            $sql .=  ", modified = ? ";
            $sql .=  ", language = ? ";
            $sql .=  ", observeruid = ? ";
            $sql .=  ", processingstatus = ? ";
            $sql .=  ", recordEnteredBy = ? ";
            $sql .=  ", duplicateQuantity = ? ";
            $sql .=  ", labelProject = ? ";
            $sql .=  ", dynamicFields = ? ";
            $sql .=  ", dateEntered = ? ";
            $sql .=  ", minimumDepthInMeters = ? ";
            $sql .=  ", maximumDepthInMeters = ? ";
            $sql .=  ", verbatimDepth = ? ";
            $sql .=  ", storageLocation = ? ";

            $sql .= "  WHERE occid = ? ";
        } else {
            $sql  = 'INSERT INTO omoccurrences ';
            $isInsert = true;
            $sql .= '( collid ,  dbpk ,  basisOfRecord ,  occurrenceID ,  catalogNumber ,  otherCatalogNumbers ,  ownerInstitutionCode ,  institutionID ,  collectionID ,  datasetID ,  institutionCode ,  collectionCode ,  family ,  scientificName ,  sciname ,  tidinterpreted ,  genus ,  specificEpithet ,  taxonRank ,  infraspecificEpithet ,  scientificNameAuthorship ,  taxonRemarks ,  identifiedBy ,  dateIdentified ,  identificationReferences ,  identificationRemarks ,  identificationQualifier ,  typeStatus ,  recordedBy ,  recordNumber ,  recordedById ,  associatedCollectors ,  eventDate , latestDateCollected,  year ,  month ,  day ,  startDayOfYear ,  endDayOfYear ,  verbatimEventDate ,  habitat ,  substrate ,  fieldNotes ,  fieldnumber , eventID, occurrenceRemarks ,  informationWithheld ,  dataGeneralizations ,  associatedOccurrences ,  associatedTaxa ,  dynamicProperties ,  verbatimAttributes ,  behavior ,  reproductiveCondition ,  cultivationStatus ,  establishmentMeans ,  lifeStage ,  sex ,  individualCount ,  samplingProtocol , samplingEffort , preparations , locationID, waterBody,  country ,  stateProvince ,  county ,  municipality ,  locality ,  localitySecurity ,  localitySecurityReason ,  decimalLatitude ,  decimalLongitude ,  geodeticDatum ,  coordinateUncertaintyInMeters ,  footprintWKT ,  coordinatePrecision ,  locationRemarks ,  verbatimCoordinates ,  verbatimCoordinateSystem ,  georeferencedBy ,  georeferenceProtocol ,  georeferenceSources ,  georeferenceVerificationStatus ,  georeferenceRemarks ,  minimumElevationInMeters ,  maximumElevationInMeters ,  verbatimElevation ,  previousIdentifications ,  disposition ,  genericcolumn1 ,  genericcolumn2 ,  modified ,  language ,  observeruid ,  processingstatus ,  recordEnteredBy ,  duplicateQuantity ,  labelProject, dynamicFields, dateEntered, minimumDepthInMeters, maximumDepthInMeters, verbatimDepth, storageLocation) VALUES (';
            $sql .=  "  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .= ')';

        }   
        if ($statement = $connection->prepare($sql)) { 
           if ($this->occid!= NULL ) {
              $statement->bind_param("issssssssssssssissssssssssssssssssiiiiisssssssssssssssissssssssssssssisddsisdssssssssiisssssssississsiissi", $this->collid , $this->dbpk , $this->basisOfRecord , $this->occurrenceID , $this->catalogNumber , $this->otherCatalogNumbers , $this->ownerInstitutionCode , $this->institutionID , $this->collectionID , $this->datasetID , $this->institutionCode , $this->collectionCode , $this->family , $this->scientificName , $this->sciname , $this->tidinterpreted , $this->genus , $this->specificEpithet , $this->taxonRank , $this->infraspecificEpithet , $this->scientificNameAuthorship , $this->taxonRemarks , $this->identifiedBy , $this->dateIdentified , $this->identificationReferences , $this->identificationRemarks , $this->identificationQualifier , $this->typeStatus , $this->recordedBy , $this->recordNumber , $this->recordedById , $this->associatedCollectors , $this->eventDate , $this->latestDateCollected , $this->year , $this->month , $this->day , $this->startDayOfYear , $this->endDayOfYear , $this->verbatimEventDate , $this->habitat , $this->substrate , $this->fieldNotes , $this->fieldnumber , $this->eventID , $this->occurrenceRemarks , $this->informationWithheld , $this->dataGeneralizations , $this->associatedOccurrences , $this->associatedTaxa , $this->dynamicProperties , $this->verbatimAttributes , $this->behavior , $this->reproductiveCondition , $this->cultivationStatus , $this->establishmentMeans , $this->lifeStage , $this->sex , $this->individualCount , $this->samplingProtocol , $this->samplingEffort , $this->preparations , $this->locationID , $this->waterBody , $this->country , $this->stateProvince , $this->county , $this->municipality , $this->locality , $this->localitySecurity , $this->localitySecurityReason , $this->decimalLatitude , $this->decimalLongitude , $this->geodeticDatum , $this->coordinateUncertaintyInMeters , $this->footprintWKT , $this->coordinatePrecision , $this->locationRemarks , $this->verbatimCoordinates , $this->verbatimCoordinateSystem , $this->georeferencedBy , $this->georeferenceProtocol , $this->georeferenceSources , $this->georeferenceVerificationStatus , $this->georeferenceRemarks , $this->minimumElevationInMeters , $this->maximumElevationInMeters , $this->verbatimElevation , $this->previousIdentifications , $this->disposition , $this->genericcolumn1 , $this->genericcolumn2 , $this->modified , $this->language , $this->observeruid , $this->processingstatus , $this->recordEnteredBy , $this->duplicateQuantity , $this->labelProject , $this->dynamicFields , $this->dateEntered , $this->minimumDepthInMeters , $this->maximumDepthInMeters , $this->verbatimDepth , $this->storageLocation , $this->occid );
           } else { 
              $statement->bind_param("issssssssssssssissssssssssssssssssiiiiisssssssssssssssissssssssssssssisddsisdssssssssiisssssssississsiiss", $this->collid , $this->dbpk , $this->basisOfRecord , $this->occurrenceID , $this->catalogNumber , $this->otherCatalogNumbers , $this->ownerInstitutionCode , $this->institutionID , $this->collectionID , $this->datasetID , $this->institutionCode , $this->collectionCode , $this->family , $this->scientificName , $this->sciname , $this->tidinterpreted , $this->genus , $this->specificEpithet , $this->taxonRank , $this->infraspecificEpithet , $this->scientificNameAuthorship , $this->taxonRemarks , $this->identifiedBy , $this->dateIdentified , $this->identificationReferences , $this->identificationRemarks , $this->identificationQualifier , $this->typeStatus , $this->recordedBy , $this->recordNumber , $this->recordedById , $this->associatedCollectors , $this->eventDate , $this->latestDateCollected , $this->year , $this->month , $this->day , $this->startDayOfYear , $this->endDayOfYear , $this->verbatimEventDate , $this->habitat , $this->substrate , $this->fieldNotes , $this->fieldnumber , $this->eventID , $this->occurrenceRemarks , $this->informationWithheld , $this->dataGeneralizations , $this->associatedOccurrences , $this->associatedTaxa , $this->dynamicProperties , $this->verbatimAttributes , $this->behavior , $this->reproductiveCondition , $this->cultivationStatus , $this->establishmentMeans , $this->lifeStage , $this->sex , $this->individualCount , $this->samplingProtocol , $this->samplingEffort , $this->preparations , $this->locationID , $this->waterBody , $this->country , $this->stateProvince , $this->county , $this->municipality , $this->locality , $this->localitySecurity , $this->localitySecurityReason , $this->decimalLatitude , $this->decimalLongitude , $this->geodeticDatum , $this->coordinateUncertaintyInMeters , $this->footprintWKT , $this->coordinatePrecision , $this->locationRemarks , $this->verbatimCoordinates , $this->verbatimCoordinateSystem , $this->georeferencedBy , $this->georeferenceProtocol , $this->georeferenceSources , $this->georeferenceVerificationStatus , $this->georeferenceRemarks , $this->minimumElevationInMeters , $this->maximumElevationInMeters , $this->verbatimElevation , $this->previousIdentifications , $this->disposition , $this->genericcolumn1 , $this->genericcolumn2 , $this->modified , $this->language , $this->observeruid , $this->processingstatus , $this->recordEnteredBy , $this->duplicateQuantity , $this->labelProject , $this->dynamicFields , $this->dateEntered , $this->minimumDepthInMeters , $this->maximumDepthInMeters , $this->verbatimDepth , $this->storageLocation );
           } 
           $statement->execute();
           $rows = $statement->affected_rows;
           if ($rows!==1) {
               $this->error = $statement->error; 
           } else { 
              if ($this->occid==NULL) { $this->occid = $statement->insert_id; } 
           }
           $statement->close();
        } else { 
            $this->error = mysqli_error($connection); 
            // Likely case for error conditions if schema changes affect field names
            // or if updates to field list produce incorrect sql.
            echo mysqli_error($connection);
        }
        if ($this->error=='') { 
            $returnvalue = true;
        };

        $this->loaded = true;
        return $returnvalue;
    }
   //---------------------------------------------------------------------------

   public function delete() {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = false;
        if($this->occid != NULL) {

           $preparedsql = 'SELECT occid FROM omoccurrences WHERE occid = ?  ' ;
          if ($statement = $connection->prepare($preparedsql)) {
             $statement->bind_param("i", $this->occid);
             $statement->execute();
             $statement->store_result();
             if ($statement->num_rows()==1) {
                  $sql = 'DELETE FROM omoccurrences WHERE occid = ?  ';
                  if ($stmt_delete = $connection->prepare($sql)) {
                     $stmt_delete->bind_param("i", $this->occid);
                     if ($stmnt_delete->execute()) {
                         $returnvalue = true;
                     } else {
                         $this->error = mysqli_error($connection);
                     }
                     $stmt_delete->close();
                  }
             } else {
                 $this->error = mysqli_error($connection);
             }
             $statement->close();
          } else {
              $this->error = mysqli_error($connection);
          }

            $this->loaded = true;
            // record was deleted, so set PK to null
            $this->occid = NULL;
        } else {
           throw new Exception('Unable to identify which record to delete, primary key is not set');
        }
        return $returnvalue;
    }
   //---------------------------------------------------------------------------

   public function count() {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = false;
        $sql = 'SELECT count(*)  FROM omoccurrences';
        if ($result = $connection->query($sql)) { 
           if ($result->num_rows()==1) {
             $row = $result->fetch_row();
             if ($row) {
                $returnvalue = $row[0];
             }
           }
        } else { 
           $this->error = mysqli_error($connection); 
        }
        mysqli_free_result($result);

        $this->loaded = true;
        return $returnvalue;
    }
   //---------------------------------------------------------------------------

   public function loadArrayKeyValueSearch($searchTermArray) {
       // ******* Note: $connection must be a mysqli object.
       global $connection;
       $returnvalue = array();
       $and = '';
       $wherebit = 'WHERE ';
       foreach($searchTermArray as $fieldname => $searchTerm) {
           if ($this->hasField($fieldname)) { 
               $operator = '='; 
               // change to a like search if a wildcard character is present
               if (!(strpos($searchTerm,'%')===false)) { $operator = 'like'; }
               if (!(strpos($searchTerm,'_')===false)) { $operator = 'like'; }
               if ($searchTerm=='[NULL]') { 
                   $wherebit .= "$and ($fieldname is null or $fieldname='') "; 
               } else { 
                   $wherebit .= "$and $fieldname $operator ? ";
                   $types = $types . $this->MySQLiFieldType($fieldname);
               } 
               $and = ' and ';
           }
       }
       $sql = "SELECT occid FROM omoccurrences $wherebit";
       if ($wherebit=='') { 
             $this->error = 'Error: No search terms provided';
       } else {
          $statement = $connection->prepare($sql);
          $vars = Array();
          $vars[] = $types;
          $i = 0;
          foreach ($searchTermArray as $value) { 
               $varname = 'bind'.$i;  // create a variable name
               $$varname = $value;    // using that variable name store the value 
               $vars[] = &$$varname;  // add a reference to the variable to the array
               $i++;
           }
           //$vars[] contains $types followed by references to variables holding each value in $searchTermArray.
          call_user_func_array(array($statement,'bind_param'),$vars);
          //$statement->bind_param($types,$names);
          $statement->execute();
          $statement->bind_result($id);
          $ids = array();
          while ($statement->fetch()) {
              $ids[] = $id;
          } // double loop to allow all data to be retrieved before preparing a new statement. 
          $statement->close();
          for ($i=0;$i<count($ids);$i++) {
              $obj = new omoccurrences();
              $obj->load($ids[$i]);
              $returnvalue[] = $obj;
              $result=true;
          }
          if ($result===false) { $this->error = mysqli_error($connection); }
       }
       return $returnvalue;
   }	

   //---------------------------------------------------------------------------

// TODO: *************** link to related tables 

   //---------------------------------------------------------------------------


   //---------------------------------------------------------------------------

   // Each field with an index has a load array method generated for it.
   public function loadArrayBycollid($searchTerm) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = array();
        $operator = "=";
        // change to a like search if a wildcard character is present
        if (!(strpos($searchTerm,"%")===false)) { $operator = "like"; }
        if (!(strpos($searchTerm,"_")===false)) { $operator = "like"; }
        $sql = "SELECT occid FROM omoccurrences WHERE collid $operator '$searchTerm'";
        $preparedsql = "SELECT occid FROM omoccurrences WHERE collid $operator ? ";
        if ($statement = $connection->prepare($preparedsql)) { 
            $statement->bind_param("s", $searchTerm);
            $statement->execute();
            $statement->bind_result($id);
            while ($statement->fetch()) { ;
                $obj = new omoccurrences();
                $obj->load($id);
                $returnvalue[] = $obj;
            }
            $statement->close();
        }
        return $returnvalue;
   }
   public function loadArrayBydbpk($searchTerm) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = array();
        $operator = "=";
        // change to a like search if a wildcard character is present
        if (!(strpos($searchTerm,"%")===false)) { $operator = "like"; }
        if (!(strpos($searchTerm,"_")===false)) { $operator = "like"; }
        $sql = "SELECT occid FROM omoccurrences WHERE dbpk $operator '$searchTerm'";
        $preparedsql = "SELECT occid FROM omoccurrences WHERE dbpk $operator ? ";
        if ($statement = $connection->prepare($preparedsql)) { 
            $statement->bind_param("s", $searchTerm);
            $statement->execute();
            $statement->bind_result($id);
            while ($statement->fetch()) { ;
                $obj = new omoccurrences();
                $obj->load($id);
                $returnvalue[] = $obj;
            }
            $statement->close();
        }
        return $returnvalue;
   }
   public function loadArrayByoccurrenceID($searchTerm) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = array();
        $operator = "=";
        // change to a like search if a wildcard character is present
        if (!(strpos($searchTerm,"%")===false)) { $operator = "like"; }
        if (!(strpos($searchTerm,"_")===false)) { $operator = "like"; }
        $sql = "SELECT occid FROM omoccurrences WHERE occurrenceID $operator '$searchTerm'";
        $preparedsql = "SELECT occid FROM omoccurrences WHERE occurrenceID $operator ? ";
        if ($statement = $connection->prepare($preparedsql)) { 
            $statement->bind_param("s", $searchTerm);
            $statement->execute();
            $statement->bind_result($id);
            while ($statement->fetch()) { ;
                $obj = new omoccurrences();
                $obj->load($id);
                $returnvalue[] = $obj;
            }
            $statement->close();
        }
        return $returnvalue;
   }
   public function loadArrayBycatalogNumber($searchTerm) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = array();
        $operator = "=";
        // change to a like search if a wildcard character is present
        if (!(strpos($searchTerm,"%")===false)) { $operator = "like"; }
        if (!(strpos($searchTerm,"_")===false)) { $operator = "like"; }
        $sql = "SELECT occid FROM omoccurrences WHERE catalogNumber $operator '$searchTerm'";
        $preparedsql = "SELECT occid FROM omoccurrences WHERE catalogNumber $operator ? ";
        if ($statement = $connection->prepare($preparedsql)) { 
            $statement->bind_param("s", $searchTerm);
            $statement->execute();
            $statement->bind_result($id);
            while ($statement->fetch()) { ;
                $obj = new omoccurrences();
                $obj->load($id);
                $returnvalue[] = $obj;
            }
            $statement->close();
        }
        return $returnvalue;
   }
   public function loadArrayByownerInstitutionCode($searchTerm) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = array();
        $operator = "=";
        // change to a like search if a wildcard character is present
        if (!(strpos($searchTerm,"%")===false)) { $operator = "like"; }
        if (!(strpos($searchTerm,"_")===false)) { $operator = "like"; }
        $sql = "SELECT occid FROM omoccurrences WHERE ownerInstitutionCode $operator '$searchTerm'";
        $preparedsql = "SELECT occid FROM omoccurrences WHERE ownerInstitutionCode $operator ? ";
        if ($statement = $connection->prepare($preparedsql)) { 
            $statement->bind_param("s", $searchTerm);
            $statement->execute();
            $statement->bind_result($id);
            while ($statement->fetch()) { ;
                $obj = new omoccurrences();
                $obj->load($id);
                $returnvalue[] = $obj;
            }
            $statement->close();
        }
        return $returnvalue;
   }
   public function loadArrayByfamily($searchTerm) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = array();
        $operator = "=";
        // change to a like search if a wildcard character is present
        if (!(strpos($searchTerm,"%")===false)) { $operator = "like"; }
        if (!(strpos($searchTerm,"_")===false)) { $operator = "like"; }
        $sql = "SELECT occid FROM omoccurrences WHERE family $operator '$searchTerm'";
        $preparedsql = "SELECT occid FROM omoccurrences WHERE family $operator ? ";
        if ($statement = $connection->prepare($preparedsql)) { 
            $statement->bind_param("s", $searchTerm);
            $statement->execute();
            $statement->bind_result($id);
            while ($statement->fetch()) { ;
                $obj = new omoccurrences();
                $obj->load($id);
                $returnvalue[] = $obj;
            }
            $statement->close();
        }
        return $returnvalue;
   }
   public function loadArrayBysciname($searchTerm) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = array();
        $operator = "=";
        // change to a like search if a wildcard character is present
        if (!(strpos($searchTerm,"%")===false)) { $operator = "like"; }
        if (!(strpos($searchTerm,"_")===false)) { $operator = "like"; }
        $sql = "SELECT occid FROM omoccurrences WHERE sciname $operator '$searchTerm'";
        $preparedsql = "SELECT occid FROM omoccurrences WHERE sciname $operator ? ";
        if ($statement = $connection->prepare($preparedsql)) { 
            $statement->bind_param("s", $searchTerm);
            $statement->execute();
            $statement->bind_result($id);
            while ($statement->fetch()) { ;
                $obj = new omoccurrences();
                $obj->load($id);
                $returnvalue[] = $obj;
            }
            $statement->close();
        }
        return $returnvalue;
   }
   public function loadArrayBytidinterpreted($searchTerm) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = array();
        $operator = "=";
        // change to a like search if a wildcard character is present
        if (!(strpos($searchTerm,"%")===false)) { $operator = "like"; }
        if (!(strpos($searchTerm,"_")===false)) { $operator = "like"; }
        $sql = "SELECT occid FROM omoccurrences WHERE tidinterpreted $operator '$searchTerm'";
        $preparedsql = "SELECT occid FROM omoccurrences WHERE tidinterpreted $operator ? ";
        if ($statement = $connection->prepare($preparedsql)) { 
            $statement->bind_param("s", $searchTerm);
            $statement->execute();
            $statement->bind_result($id);
            while ($statement->fetch()) { ;
                $obj = new omoccurrences();
                $obj->load($id);
                $returnvalue[] = $obj;
            }
            $statement->close();
        }
        return $returnvalue;
   }
   public function loadArrayByrecordedBy($searchTerm) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = array();
        $operator = "=";
        // change to a like search if a wildcard character is present
        if (!(strpos($searchTerm,"%")===false)) { $operator = "like"; }
        if (!(strpos($searchTerm,"_")===false)) { $operator = "like"; }
        $sql = "SELECT occid FROM omoccurrences WHERE recordedBy $operator '$searchTerm'";
        $preparedsql = "SELECT occid FROM omoccurrences WHERE recordedBy $operator ? ";
        if ($statement = $connection->prepare($preparedsql)) { 
            $statement->bind_param("s", $searchTerm);
            $statement->execute();
            $statement->bind_result($id);
            while ($statement->fetch()) { ;
                $obj = new omoccurrences();
                $obj->load($id);
                $returnvalue[] = $obj;
            }
            $statement->close();
        }
        return $returnvalue;
   }
   public function loadArrayByrecordNumber($searchTerm) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = array();
        $operator = "=";
        // change to a like search if a wildcard character is present
        if (!(strpos($searchTerm,"%")===false)) { $operator = "like"; }
        if (!(strpos($searchTerm,"_")===false)) { $operator = "like"; }
        $sql = "SELECT occid FROM omoccurrences WHERE recordNumber $operator '$searchTerm'";
        $preparedsql = "SELECT occid FROM omoccurrences WHERE recordNumber $operator ? ";
        if ($statement = $connection->prepare($preparedsql)) { 
            $statement->bind_param("s", $searchTerm);
            $statement->execute();
            $statement->bind_result($id);
            while ($statement->fetch()) { ;
                $obj = new omoccurrences();
                $obj->load($id);
                $returnvalue[] = $obj;
            }
            $statement->close();
        }
        return $returnvalue;
   }
   public function loadArrayByrecordedById($searchTerm) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = array();
        $operator = "=";
        // change to a like search if a wildcard character is present
        if (!(strpos($searchTerm,"%")===false)) { $operator = "like"; }
        if (!(strpos($searchTerm,"_")===false)) { $operator = "like"; }
        $sql = "SELECT occid FROM omoccurrences WHERE recordedById $operator '$searchTerm'";
        $preparedsql = "SELECT occid FROM omoccurrences WHERE recordedById $operator ? ";
        if ($statement = $connection->prepare($preparedsql)) { 
            $statement->bind_param("s", $searchTerm);
            $statement->execute();
            $statement->bind_result($id);
            while ($statement->fetch()) { ;
                $obj = new omoccurrences();
                $obj->load($id);
                $returnvalue[] = $obj;
            }
            $statement->close();
        }
        return $returnvalue;
   }
   public function loadArrayByeventDate($searchTerm) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = array();
        $operator = "=";
        // change to a like search if a wildcard character is present
        if (!(strpos($searchTerm,"%")===false)) { $operator = "like"; }
        if (!(strpos($searchTerm,"_")===false)) { $operator = "like"; }
        $sql = "SELECT occid FROM omoccurrences WHERE eventDate $operator '$searchTerm'";
        $preparedsql = "SELECT occid FROM omoccurrences WHERE eventDate $operator ? ";
        if ($statement = $connection->prepare($preparedsql)) { 
            $statement->bind_param("s", $searchTerm);
            $statement->execute();
            $statement->bind_result($id);
            while ($statement->fetch()) { ;
                $obj = new omoccurrences();
                $obj->load($id);
                $returnvalue[] = $obj;
            }
            $statement->close();
        }
        return $returnvalue;
   }
   public function loadArrayBycountry($searchTerm) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = array();
        $operator = "=";
        // change to a like search if a wildcard character is present
        if (!(strpos($searchTerm,"%")===false)) { $operator = "like"; }
        if (!(strpos($searchTerm,"_")===false)) { $operator = "like"; }
        $sql = "SELECT occid FROM omoccurrences WHERE country $operator '$searchTerm'";
        $preparedsql = "SELECT occid FROM omoccurrences WHERE country $operator ? ";
        if ($statement = $connection->prepare($preparedsql)) { 
            $statement->bind_param("s", $searchTerm);
            $statement->execute();
            $statement->bind_result($id);
            while ($statement->fetch()) { ;
                $obj = new omoccurrences();
                $obj->load($id);
                $returnvalue[] = $obj;
            }
            $statement->close();
        }
        return $returnvalue;
   }
   public function loadArrayBystateProvince($searchTerm) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = array();
        $operator = "=";
        // change to a like search if a wildcard character is present
        if (!(strpos($searchTerm,"%")===false)) { $operator = "like"; }
        if (!(strpos($searchTerm,"_")===false)) { $operator = "like"; }
        $sql = "SELECT occid FROM omoccurrences WHERE stateProvince $operator '$searchTerm'";
        $preparedsql = "SELECT occid FROM omoccurrences WHERE stateProvince $operator ? ";
        if ($statement = $connection->prepare($preparedsql)) { 
            $statement->bind_param("s", $searchTerm);
            $statement->execute();
            $statement->bind_result($id);
            while ($statement->fetch()) { ;
                $obj = new omoccurrences();
                $obj->load($id);
                $returnvalue[] = $obj;
            }
            $statement->close();
        }
        return $returnvalue;
   }
   public function loadArrayBycounty($searchTerm) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = array();
        $operator = "=";
        // change to a like search if a wildcard character is present
        if (!(strpos($searchTerm,"%")===false)) { $operator = "like"; }
        if (!(strpos($searchTerm,"_")===false)) { $operator = "like"; }
        $sql = "SELECT occid FROM omoccurrences WHERE county $operator '$searchTerm'";
        $preparedsql = "SELECT occid FROM omoccurrences WHERE county $operator ? ";
        if ($statement = $connection->prepare($preparedsql)) { 
            $statement->bind_param("s", $searchTerm);
            $statement->execute();
            $statement->bind_result($id);
            while ($statement->fetch()) { ;
                $obj = new omoccurrences();
                $obj->load($id);
                $returnvalue[] = $obj;
            }
            $statement->close();
        }
        return $returnvalue;
   }
   public function loadArrayBymunicipality($searchTerm) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = array();
        $operator = "=";
        // change to a like search if a wildcard character is present
        if (!(strpos($searchTerm,"%")===false)) { $operator = "like"; }
        if (!(strpos($searchTerm,"_")===false)) { $operator = "like"; }
        $sql = "SELECT occid FROM omoccurrences WHERE municipality $operator '$searchTerm'";
        $preparedsql = "SELECT occid FROM omoccurrences WHERE municipality $operator ? ";
        if ($statement = $connection->prepare($preparedsql)) { 
            $statement->bind_param("s", $searchTerm);
            $statement->execute();
            $statement->bind_result($id);
            while ($statement->fetch()) { ;
                $obj = new omoccurrences();
                $obj->load($id);
                $returnvalue[] = $obj;
            }
            $statement->close();
        }
        return $returnvalue;
   }
   public function loadArrayByobserveruid($searchTerm) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = array();
        $operator = "=";
        // change to a like search if a wildcard character is present
        if (!(strpos($searchTerm,"%")===false)) { $operator = "like"; }
        if (!(strpos($searchTerm,"_")===false)) { $operator = "like"; }
        $sql = "SELECT occid FROM omoccurrences WHERE observeruid $operator '$searchTerm'";
        $preparedsql = "SELECT occid FROM omoccurrences WHERE observeruid $operator ? ";
        if ($statement = $connection->prepare($preparedsql)) { 
            $statement->bind_param("s", $searchTerm);
            $statement->execute();
            $statement->bind_result($id);
            while ($statement->fetch()) { ;
                $obj = new omoccurrences();
                $obj->load($id);
                $returnvalue[] = $obj;
            }
            $statement->close();
        }
        return $returnvalue;
   }
   public function loadArrayByprocessingstatus($searchTerm) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = array();
        $operator = "=";
        // change to a like search if a wildcard character is present
        if (!(strpos($searchTerm,"%")===false)) { $operator = "like"; }
        if (!(strpos($searchTerm,"_")===false)) { $operator = "like"; }
        $sql = "SELECT occid FROM omoccurrences WHERE processingstatus $operator '$searchTerm'";
        $preparedsql = "SELECT occid FROM omoccurrences WHERE processingstatus $operator ? ";
        if ($statement = $connection->prepare($preparedsql)) { 
            $statement->bind_param("s", $searchTerm);
            $statement->execute();
            $statement->bind_result($id);
            while ($statement->fetch()) { ;
                $obj = new omoccurrences();
                $obj->load($id);
                $returnvalue[] = $obj;
            }
            $statement->close();
        }
        return $returnvalue;
   }

   //---------------------------------------------------------------------------

   // Each fulltext index has a load array method generated for it.

   //---------------------------------------------------------------------------

   // Each field with an index has a select distinct method generated for it.
   public function selectDistinctcollid($startline,$link,$endline,$includecount=false,$orderbycount=false) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = '';
        $order = ' collid ';
        if ($orderbycount) { $order = ' druid_ct DESC '; } 
        $sql = "SELECT count(*) as druid_ct, collid FROM omoccurrences group by collid order by $order ";
        if ($result = $connection->query($sql)) { 
           while ($row = $result->fetch_row()) {
              if ($row) {
                  $count = $row[0];
                  $val = $row[1];
                  $escaped = urlencode($row[1]);
                  if ($val=='') {
                     $val = '[NULL]'; 
                     $escaped = urlencode('[NULL]');
                  }
                  if ($link=='') { 
                     $returnvalue .= "$startline$val&nbsp;($count)$endline";
                  } else { 
                     $returnvalue .= "$startline<a href='$link&collid=$escaped'>$val</a>&nbsp;($count)$endline";
                  }
              }
           }
           $result->close();
        }
        return $returnvalue;
    }
   public function selectDistinctdbpk($startline,$link,$endline,$includecount=false,$orderbycount=false) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = '';
        $order = ' dbpk ';
        if ($orderbycount) { $order = ' druid_ct DESC '; } 
        $sql = "SELECT count(*) as druid_ct, dbpk FROM omoccurrences group by dbpk order by $order ";
        if ($result = $connection->query($sql)) { 
           while ($row = $result->fetch_row()) {
              if ($row) {
                  $count = $row[0];
                  $val = $row[1];
                  $escaped = urlencode($row[1]);
                  if ($val=='') {
                     $val = '[NULL]'; 
                     $escaped = urlencode('[NULL]');
                  }
                  if ($link=='') { 
                     $returnvalue .= "$startline$val&nbsp;($count)$endline";
                  } else { 
                     $returnvalue .= "$startline<a href='$link&dbpk=$escaped'>$val</a>&nbsp;($count)$endline";
                  }
              }
           }
           $result->close();
        }
        return $returnvalue;
    }
   public function selectDistinctoccurrenceID($startline,$link,$endline,$includecount=false,$orderbycount=false) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = '';
        $order = ' occurrenceID ';
        if ($orderbycount) { $order = ' druid_ct DESC '; } 
        $sql = "SELECT count(*) as druid_ct, occurrenceID FROM omoccurrences group by occurrenceID order by $order ";
        if ($result = $connection->query($sql)) { 
           while ($row = $result->fetch_row()) {
              if ($row) {
                  $count = $row[0];
                  $val = $row[1];
                  $escaped = urlencode($row[1]);
                  if ($val=='') {
                     $val = '[NULL]'; 
                     $escaped = urlencode('[NULL]');
                  }
                  if ($link=='') { 
                     $returnvalue .= "$startline$val&nbsp;($count)$endline";
                  } else { 
                     $returnvalue .= "$startline<a href='$link&occurrenceID=$escaped'>$val</a>&nbsp;($count)$endline";
                  }
              }
           }
           $result->close();
        }
        return $returnvalue;
    }
   public function selectDistinctcatalogNumber($startline,$link,$endline,$includecount=false,$orderbycount=false) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = '';
        $order = ' catalogNumber ';
        if ($orderbycount) { $order = ' druid_ct DESC '; } 
        $sql = "SELECT count(*) as druid_ct, catalogNumber FROM omoccurrences group by catalogNumber order by $order ";
        if ($result = $connection->query($sql)) { 
           while ($row = $result->fetch_row()) {
              if ($row) {
                  $count = $row[0];
                  $val = $row[1];
                  $escaped = urlencode($row[1]);
                  if ($val=='') {
                     $val = '[NULL]'; 
                     $escaped = urlencode('[NULL]');
                  }
                  if ($link=='') { 
                     $returnvalue .= "$startline$val&nbsp;($count)$endline";
                  } else { 
                     $returnvalue .= "$startline<a href='$link&catalogNumber=$escaped'>$val</a>&nbsp;($count)$endline";
                  }
              }
           }
           $result->close();
        }
        return $returnvalue;
    }
   public function selectDistinctownerInstitutionCode($startline,$link,$endline,$includecount=false,$orderbycount=false) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = '';
        $order = ' ownerInstitutionCode ';
        if ($orderbycount) { $order = ' druid_ct DESC '; } 
        $sql = "SELECT count(*) as druid_ct, ownerInstitutionCode FROM omoccurrences group by ownerInstitutionCode order by $order ";
        if ($result = $connection->query($sql)) { 
           while ($row = $result->fetch_row()) {
              if ($row) {
                  $count = $row[0];
                  $val = $row[1];
                  $escaped = urlencode($row[1]);
                  if ($val=='') {
                     $val = '[NULL]'; 
                     $escaped = urlencode('[NULL]');
                  }
                  if ($link=='') { 
                     $returnvalue .= "$startline$val&nbsp;($count)$endline";
                  } else { 
                     $returnvalue .= "$startline<a href='$link&ownerInstitutionCode=$escaped'>$val</a>&nbsp;($count)$endline";
                  }
              }
           }
           $result->close();
        }
        return $returnvalue;
    }
   public function selectDistinctfamily($startline,$link,$endline,$includecount=false,$orderbycount=false) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = '';
        $order = ' family ';
        if ($orderbycount) { $order = ' druid_ct DESC '; } 
        $sql = "SELECT count(*) as druid_ct, family FROM omoccurrences group by family order by $order ";
        if ($result = $connection->query($sql)) { 
           while ($row = $result->fetch_row()) {
              if ($row) {
                  $count = $row[0];
                  $val = $row[1];
                  $escaped = urlencode($row[1]);
                  if ($val=='') {
                     $val = '[NULL]'; 
                     $escaped = urlencode('[NULL]');
                  }
                  if ($link=='') { 
                     $returnvalue .= "$startline$val&nbsp;($count)$endline";
                  } else { 
                     $returnvalue .= "$startline<a href='$link&family=$escaped'>$val</a>&nbsp;($count)$endline";
                  }
              }
           }
           $result->close();
        }
        return $returnvalue;
    }
   public function selectDistinctsciname($startline,$link,$endline,$includecount=false,$orderbycount=false) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = '';
        $order = ' sciname ';
        if ($orderbycount) { $order = ' druid_ct DESC '; } 
        $sql = "SELECT count(*) as druid_ct, sciname FROM omoccurrences group by sciname order by $order ";
        if ($result = $connection->query($sql)) { 
           while ($row = $result->fetch_row()) {
              if ($row) {
                  $count = $row[0];
                  $val = $row[1];
                  $escaped = urlencode($row[1]);
                  if ($val=='') {
                     $val = '[NULL]'; 
                     $escaped = urlencode('[NULL]');
                  }
                  if ($link=='') { 
                     $returnvalue .= "$startline$val&nbsp;($count)$endline";
                  } else { 
                     $returnvalue .= "$startline<a href='$link&sciname=$escaped'>$val</a>&nbsp;($count)$endline";
                  }
              }
           }
           $result->close();
        }
        return $returnvalue;
    }
   public function selectDistincttidinterpreted($startline,$link,$endline,$includecount=false,$orderbycount=false) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = '';
        $order = ' tidinterpreted ';
        if ($orderbycount) { $order = ' druid_ct DESC '; } 
        $sql = "SELECT count(*) as druid_ct, tidinterpreted FROM omoccurrences group by tidinterpreted order by $order ";
        if ($result = $connection->query($sql)) { 
           while ($row = $result->fetch_row()) {
              if ($row) {
                  $count = $row[0];
                  $val = $row[1];
                  $escaped = urlencode($row[1]);
                  if ($val=='') {
                     $val = '[NULL]'; 
                     $escaped = urlencode('[NULL]');
                  }
                  if ($link=='') { 
                     $returnvalue .= "$startline$val&nbsp;($count)$endline";
                  } else { 
                     $returnvalue .= "$startline<a href='$link&tidinterpreted=$escaped'>$val</a>&nbsp;($count)$endline";
                  }
              }
           }
           $result->close();
        }
        return $returnvalue;
    }
   public function selectDistinctrecordedBy($startline,$link,$endline,$includecount=false,$orderbycount=false) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = '';
        $order = ' recordedBy ';
        if ($orderbycount) { $order = ' druid_ct DESC '; } 
        $sql = "SELECT count(*) as druid_ct, recordedBy FROM omoccurrences group by recordedBy order by $order ";
        if ($result = $connection->query($sql)) { 
           while ($row = $result->fetch_row()) {
              if ($row) {
                  $count = $row[0];
                  $val = $row[1];
                  $escaped = urlencode($row[1]);
                  if ($val=='') {
                     $val = '[NULL]'; 
                     $escaped = urlencode('[NULL]');
                  }
                  if ($link=='') { 
                     $returnvalue .= "$startline$val&nbsp;($count)$endline";
                  } else { 
                     $returnvalue .= "$startline<a href='$link&recordedBy=$escaped'>$val</a>&nbsp;($count)$endline";
                  }
              }
           }
           $result->close();
        }
        return $returnvalue;
    }
   public function selectDistinctrecordNumber($startline,$link,$endline,$includecount=false,$orderbycount=false) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = '';
        $order = ' recordNumber ';
        if ($orderbycount) { $order = ' druid_ct DESC '; } 
        $sql = "SELECT count(*) as druid_ct, recordNumber FROM omoccurrences group by recordNumber order by $order ";
        if ($result = $connection->query($sql)) { 
           while ($row = $result->fetch_row()) {
              if ($row) {
                  $count = $row[0];
                  $val = $row[1];
                  $escaped = urlencode($row[1]);
                  if ($val=='') {
                     $val = '[NULL]'; 
                     $escaped = urlencode('[NULL]');
                  }
                  if ($link=='') { 
                     $returnvalue .= "$startline$val&nbsp;($count)$endline";
                  } else { 
                     $returnvalue .= "$startline<a href='$link&recordNumber=$escaped'>$val</a>&nbsp;($count)$endline";
                  }
              }
           }
           $result->close();
        }
        return $returnvalue;
    }
   public function selectDistinctrecordedById($startline,$link,$endline,$includecount=false,$orderbycount=false) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = '';
        $order = ' recordedById ';
        if ($orderbycount) { $order = ' druid_ct DESC '; } 
        $sql = "SELECT count(*) as druid_ct, recordedById FROM omoccurrences group by recordedById order by $order ";
        if ($result = $connection->query($sql)) { 
           while ($row = $result->fetch_row()) {
              if ($row) {
                  $count = $row[0];
                  $val = $row[1];
                  $escaped = urlencode($row[1]);
                  if ($val=='') {
                     $val = '[NULL]'; 
                     $escaped = urlencode('[NULL]');
                  }
                  if ($link=='') { 
                     $returnvalue .= "$startline$val&nbsp;($count)$endline";
                  } else { 
                     $returnvalue .= "$startline<a href='$link&recordedById=$escaped'>$val</a>&nbsp;($count)$endline";
                  }
              }
           }
           $result->close();
        }
        return $returnvalue;
    }
   public function selectDistincteventDate($startline,$link,$endline,$includecount=false,$orderbycount=false) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = '';
        $order = ' eventDate ';
        if ($orderbycount) { $order = ' druid_ct DESC '; } 
        $sql = "SELECT count(*) as druid_ct, eventDate FROM omoccurrences group by eventDate order by $order ";
        if ($result = $connection->query($sql)) { 
           while ($row = $result->fetch_row()) {
              if ($row) {
                  $count = $row[0];
                  $val = $row[1];
                  $escaped = urlencode($row[1]);
                  if ($val=='') {
                     $val = '[NULL]'; 
                     $escaped = urlencode('[NULL]');
                  }
                  if ($link=='') { 
                     $returnvalue .= "$startline$val&nbsp;($count)$endline";
                  } else { 
                     $returnvalue .= "$startline<a href='$link&eventDate=$escaped'>$val</a>&nbsp;($count)$endline";
                  }
              }
           }
           $result->close();
        }
        return $returnvalue;
    }
   public function selectDistinctcountry($startline,$link,$endline,$includecount=false,$orderbycount=false) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = '';
        $order = ' country ';
        if ($orderbycount) { $order = ' druid_ct DESC '; } 
        $sql = "SELECT count(*) as druid_ct, country FROM omoccurrences group by country order by $order ";
        if ($result = $connection->query($sql)) { 
           while ($row = $result->fetch_row()) {
              if ($row) {
                  $count = $row[0];
                  $val = $row[1];
                  $escaped = urlencode($row[1]);
                  if ($val=='') {
                     $val = '[NULL]'; 
                     $escaped = urlencode('[NULL]');
                  }
                  if ($link=='') { 
                     $returnvalue .= "$startline$val&nbsp;($count)$endline";
                  } else { 
                     $returnvalue .= "$startline<a href='$link&country=$escaped'>$val</a>&nbsp;($count)$endline";
                  }
              }
           }
           $result->close();
        }
        return $returnvalue;
    }
   public function selectDistinctstateProvince($startline,$link,$endline,$includecount=false,$orderbycount=false) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = '';
        $order = ' stateProvince ';
        if ($orderbycount) { $order = ' druid_ct DESC '; } 
        $sql = "SELECT count(*) as druid_ct, stateProvince FROM omoccurrences group by stateProvince order by $order ";
        if ($result = $connection->query($sql)) { 
           while ($row = $result->fetch_row()) {
              if ($row) {
                  $count = $row[0];
                  $val = $row[1];
                  $escaped = urlencode($row[1]);
                  if ($val=='') {
                     $val = '[NULL]'; 
                     $escaped = urlencode('[NULL]');
                  }
                  if ($link=='') { 
                     $returnvalue .= "$startline$val&nbsp;($count)$endline";
                  } else { 
                     $returnvalue .= "$startline<a href='$link&stateProvince=$escaped'>$val</a>&nbsp;($count)$endline";
                  }
              }
           }
           $result->close();
        }
        return $returnvalue;
    }
   public function selectDistinctcounty($startline,$link,$endline,$includecount=false,$orderbycount=false) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = '';
        $order = ' county ';
        if ($orderbycount) { $order = ' druid_ct DESC '; } 
        $sql = "SELECT count(*) as druid_ct, county FROM omoccurrences group by county order by $order ";
        if ($result = $connection->query($sql)) { 
           while ($row = $result->fetch_row()) {
              if ($row) {
                  $count = $row[0];
                  $val = $row[1];
                  $escaped = urlencode($row[1]);
                  if ($val=='') {
                     $val = '[NULL]'; 
                     $escaped = urlencode('[NULL]');
                  }
                  if ($link=='') { 
                     $returnvalue .= "$startline$val&nbsp;($count)$endline";
                  } else { 
                     $returnvalue .= "$startline<a href='$link&county=$escaped'>$val</a>&nbsp;($count)$endline";
                  }
              }
           }
           $result->close();
        }
        return $returnvalue;
    }
   public function selectDistinctmunicipality($startline,$link,$endline,$includecount=false,$orderbycount=false) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = '';
        $order = ' municipality ';
        if ($orderbycount) { $order = ' druid_ct DESC '; } 
        $sql = "SELECT count(*) as druid_ct, municipality FROM omoccurrences group by municipality order by $order ";
        if ($result = $connection->query($sql)) { 
           while ($row = $result->fetch_row()) {
              if ($row) {
                  $count = $row[0];
                  $val = $row[1];
                  $escaped = urlencode($row[1]);
                  if ($val=='') {
                     $val = '[NULL]'; 
                     $escaped = urlencode('[NULL]');
                  }
                  if ($link=='') { 
                     $returnvalue .= "$startline$val&nbsp;($count)$endline";
                  } else { 
                     $returnvalue .= "$startline<a href='$link&municipality=$escaped'>$val</a>&nbsp;($count)$endline";
                  }
              }
           }
           $result->close();
        }
        return $returnvalue;
    }
   public function selectDistinctobserveruid($startline,$link,$endline,$includecount=false,$orderbycount=false) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = '';
        $order = ' observeruid ';
        if ($orderbycount) { $order = ' druid_ct DESC '; } 
        $sql = "SELECT count(*) as druid_ct, observeruid FROM omoccurrences group by observeruid order by $order ";
        if ($result = $connection->query($sql)) { 
           while ($row = $result->fetch_row()) {
              if ($row) {
                  $count = $row[0];
                  $val = $row[1];
                  $escaped = urlencode($row[1]);
                  if ($val=='') {
                     $val = '[NULL]'; 
                     $escaped = urlencode('[NULL]');
                  }
                  if ($link=='') { 
                     $returnvalue .= "$startline$val&nbsp;($count)$endline";
                  } else { 
                     $returnvalue .= "$startline<a href='$link&observeruid=$escaped'>$val</a>&nbsp;($count)$endline";
                  }
              }
           }
           $result->close();
        }
        return $returnvalue;
    }
    public function selectDistinctprocessingstatus($startline,$link,$endline,$includecount=false,$orderbycount=false) {
         // ******* Note: $connection must be a mysqli object.
         global $connection;
         $returnvalue = '';
         $order = ' processingstatus ';
         if ($orderbycount) { $order = ' druid_ct DESC '; } 
         $sql = "SELECT count(*) as druid_ct, processingstatus FROM omoccurrences group by processingstatus order by $order ";
         if ($result = $connection->query($sql)) { 
            while ($row = $result->fetch_row()) {
               if ($row) {
                   $count = $row[0];
                   $val = $row[1];
                   $escaped = urlencode($row[1]);
                   if ($val=='') {
                      $val = '[NULL]'; 
                      $escaped = urlencode('[NULL]');
                   }
                   if ($link=='') { 
                      $returnvalue .= "$startline$val&nbsp;($count)$endline";
                   } else { 
                      $returnvalue .= "$startline<a href='$link&processingstatus=$escaped'>$val</a>&nbsp;($count)$endline";
                   }
               }
            }
            $result->close();
         }
         return $returnvalue;
   }

   public function keySelectDistinct($fieldname,$startline,$link,$endline,$includecount=false,$orderbycount=false) {
       $returnvalue = '';
       switch ($fieldname) { 
          case 'collid':
             $returnvalue = $this->selectDistinctcollid($startline,$link,$endline,$includecount,$orderbycount);
             break;
          case 'dbpk':
             $returnvalue = $this->selectDistinctdbpk($startline,$link,$endline,$includecount,$orderbycount);
             break;
          case 'occurrenceID':
             $returnvalue = $this->selectDistinctoccurrenceID($startline,$link,$endline,$includecount,$orderbycount);
             break;
          case 'catalogNumber':
             $returnvalue = $this->selectDistinctcatalogNumber($startline,$link,$endline,$includecount,$orderbycount);
             break;
          case 'ownerInstitutionCode':
             $returnvalue = $this->selectDistinctownerInstitutionCode($startline,$link,$endline,$includecount,$orderbycount);
             break;
          case 'family':
             $returnvalue = $this->selectDistinctfamily($startline,$link,$endline,$includecount,$orderbycount);
             break;
          case 'sciname':
             $returnvalue = $this->selectDistinctsciname($startline,$link,$endline,$includecount,$orderbycount);
             break;
          case 'tidinterpreted':
             $returnvalue = $this->selectDistincttidinterpreted($startline,$link,$endline,$includecount,$orderbycount);
             break;
          case 'recordedBy':
             $returnvalue = $this->selectDistinctrecordedBy($startline,$link,$endline,$includecount,$orderbycount);
             break;
          case 'recordNumber':
             $returnvalue = $this->selectDistinctrecordNumber($startline,$link,$endline,$includecount,$orderbycount);
             break;
          case 'recordedById':
             $returnvalue = $this->selectDistinctrecordedById($startline,$link,$endline,$includecount,$orderbycount);
             break;
          case 'eventDate':
             $returnvalue = $this->selectDistincteventDate($startline,$link,$endline,$includecount,$orderbycount);
             break;
          case 'country':
             $returnvalue = $this->selectDistinctcountry($startline,$link,$endline,$includecount,$orderbycount);
             break;
          case 'stateProvince':
             $returnvalue = $this->selectDistinctstateProvince($startline,$link,$endline,$includecount,$orderbycount);
             break;
          case 'county':
             $returnvalue = $this->selectDistinctcounty($startline,$link,$endline,$includecount,$orderbycount);
             break;
          case 'municipality':
             $returnvalue = $this->selectDistinctmunicipality($startline,$link,$endline,$includecount,$orderbycount);
             break;
          case 'observeruid':
             $returnvalue = $this->selectDistinctobserveruid($startline,$link,$endline,$includecount,$orderbycount);
             break;
          case 'processingstatus':
             $returnvalue = $this->selectDistinctprocessingstatus($startline,$link,$endline,$includecount,$orderbycount);
             break;
       }
       return $returnvalue;
    }

   //---------------------------------------------------------------------------

   public function hasField($fieldname) {
       $returnvalue = false;
       if (trim($fieldname)!='' && trim($fieldname)!=',') {
            if (strpos(self::FIELDLIST," $fieldname, ")!==false) { 
               $returnvalue = true;
            }
       }
       return $returnvalue;
    }
   //---------------------------------------------------------------------------

}

//==============================================================================
?>