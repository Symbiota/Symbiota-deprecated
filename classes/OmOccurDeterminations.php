<?php
//==============================================================================
//===   omoccurdeterminations.php                         
//===   Autogenerated by Druid from MySQL db Build:4
//==============================================================================

// Up to date with schema version 1.0

include_once($SERVER_ROOT.'/config/dbconnection.php');
$connection = MySQLiConnectionFactory::getCon("write");

class OmOccurDeterminations {

    public function __construct(){
        //if (!$this->checkSchema()) { 
        //    echo "[Warning: classes/OmOccurDeterminations.php does not match the Symbiota schema version.]\n";
        //    echo "[Warning: Ingest of data may fail.  Contact a Symbiota developer.]\n";
        //}
    }

   /** 
    * Test to see if this class version is compatible with the current schema version.
    *
    * @see config/schema/utf8/db_schema_patch_1.0.template.sql
    */
   public function checkSchema() {
        global $connection;
        $result = false;

        /*****  Warning: Do not override this check in order to supress error messages.
         *****  If a warning is encountered, this class must be updated, or code that
         *****  invokes it may fail in unpredictable ways. */

        // This is a PDO class for OmOccurDeterminations.  If no change was made to that
        // table in a schema update, then the supported schema version may simply be added.
        // If, however, changes were made to the table, they must be reflected in this class.

        //$supportedVersions[] = '0.9.1.14';
        //$supportedVersions[] = '0.9.1.15';
        $supportedVersions[] = '0.9.1.16';
        $supportedVersions[] = '1.0';
        $supportedVersions[] = '1.1';
        
        // Find the most recently applied version number
        $preparesql = "select versionnumber from schemaversion order by dateapplied desc limit 1;";
        if ($statement = $connection->prepare($preparesql)) {
            $statement->execute();
            $statement->bind_result($versionnumber);
            $statement->fetch();
            if (in_array($versionnumber,$supportedVersions)) {
               $result = true;
            }
       }
       return $result;
   }
 
   /**
    * Check the taxa.securitystatus for a tid.  If no tid 
    * is given, check the taxa.securitystatus for the 
    * tidInterpreted for the current omoccurdeterminations.
    * @param tid 
    * @return 1 if the taxon has a security status of 1, 
    *   0 otherwise.
    */
   public function checkSecurityStatus($tid=null) { 
      global $connection;
      $result = 0;
      if ($tid==null) { 
        $tid = $this->tidInterpreted;
      } 
      if ($tid<>null) { 
        $sql = 'select t.securityStatus from taxa t where t.tid = ? ';
        if ($statement = $connection->prepare($sql)) {
           $statement->bind_param("i", $tid);
           $statement->execute();
           $statement->bind_result($result);
           $statement->fetch();
           $statement->close();
        }
      }
      return $result;
   } 


   // These constants hold the sizes the fields in this table in the database.
   const DETID_SIZE           = 11; //INTEGER
   const OCCID_SIZE           = 11; //INT
   const IDENTIFIEDBY_SIZE    = 60; //60
   const IDBYID_SIZE          = 11; // INT
   const DATEIDENTIFIED_SIZE  = 45; //45
   const DATEIDENTIFIEDINTERPRETED_SIZE = 12;
   const SCINAME_SIZE         = 100; //100
   const SCIENTIFICNAMEAUTHORSHIP_SIZE = 100; //100
   const IDENTIFICATIONQUALIFIER_SIZE = 45; //45
   const IDENTIFICATIONREFERENCES_SIZE = 255; //255
   const IDENTIFICATIONREMARKS_SIZE = 500; //500
   const SORTSEQUENCE_SIZE    = 11; //INTEGER
   const INITIALTIMESTAMP_SIZE = 21; //TIMESTAMP
   const ISCURRENT_SIZE       = 2; // INT(2)
   const PRINTQUEUE_SIZE      = 2; // INT(2)
   const APPLIEDSTATUS_SIZE   = 2; // INT(2)
   const DETTYPE_SIZE         = 45; // VARCHAR(45)
   const TIDINTERPRETED_SIZE  = 11; // INT
   const SOURCEIDENTIFIER_SIZE  = 45; //45
    // These constants hold the field names of the table in the database. 
   const DETID             = 'detid';
   const OCCID             = 'occid';
   const IDENTIFIEDBY      = 'identifiedBy';
   const IDBYID            = 'idbyid';
   const DATEIDENTIFIED    = 'dateIdentified';
   const DATEIDENTIFIEDINTERPRETED = 'dateIdentifiedInterpreted';
   const SCINAME           = 'sciname';
   const SCIENTIFICNAMEAUTHORSHIP = 'scientificNameAuthorship';
   const IDENTIFICATIONQUALIFIER = 'identificationQualifier';
   const IDENTIFICATIONREFERENCES = 'identificationReferences';
   const IDENTIFICATIONREMARKS = 'identificationRemarks';
   const SORTSEQUENCE      = 'sortsequence';
   const INITIALTIMESTAMP  = 'initialtimestamp';
   const ISCURRENT         = 'isCurrent';
   const PRINTQUEUE        = 'printqueue';
   const APPLIEDSTATUS     = 'appliedStatus';
   const DETTYPE           = 'detType';
   const TIDINTERPRETED    = 'tidInterpreted';
   const SOURCEIDENTIFIER  = 'sourceIdentifier';

   //---------------------------------------------------------------------------

   // interface tableSchema implementation
   // schemaPK returns array of primary key field names
   public function schemaPK() {
       return $this->primaryKeyArray;
   } 
   // schemaHaveDistinct returns array of field names for which selectDistinct{fieldname} methods are available.
   public function schemaHaveDistinct() {
       return $this->selectDistinctFieldsArray;
   } 
   // schemaFields returns array of all field names
   public function schemaFields() { 
       return $this->allFieldsArray;
   } 
/*  Example sanitized retrieval of variable matching object variables from $_GET 
/*  Customize these to limit each variable to narrowest possible set of known good values. 

  $detid = substr(preg_replace('/[^0-9\-\[NULL\]]/','',$_GET['detid']), 0, 11);
  $occid = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['occid']), 0, 11);
  $identifiedBy = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['identifiedBy']), 0, 45);
  $dateIdentified = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['dateIdentified']), 0, 45);
  $sciname = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['sciname']), 0, 100);
  $scientificNameAuthorship = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['scientificNameAuthorship']), 0, 100);
  $identificationQualifier = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['identificationQualifier']), 0, 45);
  $identificationReferences = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['identificationReferences']), 0, 255);
  $identificationRemarks = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['identificationRemarks']), 0, 500);
  $sortsequence = substr(preg_replace('/[^0-9\-\[NULL\]]/','',$_GET['sortsequence']), 0, 11);
  $initialtimestamp = substr(preg_replace('/[^A-Za-z0-9\.\.\ \[NULL\]]/','',$_GET['initialtimestamp']), 0, 21);
*/

   //---------------------------------------------------------------------------

   private $detid; // PK INTEGER 
   private $occid; // INT 
   private $identifiedBy; // VARCHAR(45) 
   private $dateIdentified; // VARCHAR(45) 
   private $dateIdentifiedInterpreted; //DATE
   private $sciname; // VARCHAR(100) 
   private $scientificNameAuthorship; // VARCHAR(100) 
   private $identificationQualifier; // VARCHAR(45) 
   private $identificationReferences; // VARCHAR(255) 
   private $identificationRemarks; // VARCHAR(500) 
   private $sortsequence; // INTEGER 
   private $initialtimestamp; // TIMESTAMP 
   private $idbyid;
   private $isCurrent;
   private $printQueue; //INT(2)
   private $appliedStatus;
   private $detType; //VARCHAR(45)
   private $tidInterpreted;
   private $dirty;
   private $loaded;
   private $error;
   const FIELDLIST = ' detid, occid, identifiedBy, dateIdentified, dateIdentifiedInterpreted; sciname, scientificNameAuthorship, identificationQualifier, identificationReferences, identificationRemarks, sortsequence, initialtimestamp, idbyid, isCurrent, printqueue, appliedStatus, detType, tidInterpreted,sourceIdentifier';
   const PKFIELDLIST = ' detid, ';
   const NUMBER_OF_PRIMARY_KEYS = 1;
   private $primaryKeyArray = array( 1 => 'detid'  ) ;
   private $allFieldsArray = array( 0 => 'detid' , 1 => 'occid' , 2 => 'identifiedBy' , 3 => 'dateIdentified' , 4 => 'dateIdentifiedInterpreted' , 5 => 'sciname' , 6 => 'scientificNameAuthorship' , 7 => 'identificationQualifier' , 8 => 'identificationReferences' , 9 => 'identificationRemarks' , 10 => 'sortsequence' , 11 => 'initialtimestamp' , 12 => 'idbyid' , 13 => 'isCurrent' , 14 => 'printqueue' , 15 => 'appliedStatus' , 16 => 'detType' , 17 => 'tidInterpreted', 18 => 'sourceIdentifier'  ) ;
   private $selectDistinctFieldsArray = array( 1 => 'occid' , 2 => 'identifiedBy' , 3 => 'dateIdentified'  ) ;

   //---------------------------------------------------------------------------

   // constructor 
   function OmOccurDeterminations(){
       $this->detid = NULL;
       $this->occid = '';
       $this->identifiedBy = '';
       $this->dateIdentified = '';
       $this->dateIdentifiedInterpreted = NULL;
       $this->sciname = '';
       $this->scientificNameAuthorship = '';
       $this->identificationQualifier = '';
       $this->identificationReferences = '';
       $this->identificationRemarks = '';
       $this->sortsequence = '';
       $this->initialtimestamp = '';
       $this->idbyid = NULL;
       $this->isCurrent = 0;
       $this->printQueue = 0;
       $this->appliedStatus = 1;
       $this->detType = '';
       $this->tidInterpreted = NULL;
       $this->sourceIdentifier = NULL;
       $this->dirty = false;
       $this->loaded = false;
       $this->error = '';
   }

   /** 
    * Find the first matching symbiota taxon.tid for a scientific name.
    *
    * @param sciname the scientific name, without authorship.
    * @return the taxon.tid for the scientific name, or null if not found.
    */
   public static function lookupTID($sciname) {
       global $connection;
       $returnvalue = null;
       if ($sciname==null) {
           $sql = 'select tid from taxa where sciname = ? ';
           if ($statement = $connection->prepare($sql)) {
              $statement->bind_param("s", $sciname);
              $statement->execute();
              $statement->bind_result($returnvalue);
              $statement->fetch();
              $statement->close();
           }
       }
       return $returnvalue;
   }

   /** 
    * Find the first matching symbiota accepted taxon.tid for a scientific name.
    *
    * @param sciname the scientific name, without authorship.
    * @return the taxa.tid for the accepted name, or null if not found.
    */
   public static function lookupAcceptedTID($sciname) {
       global $connection;
       $returnvalue = null;
       if ($sciname==null) {
           $sql = 'select a.tidaccepted, t.tid from taxa t left join taxstatus a on t.tid = a.tid where t.sciname = ? ';
           if ($statement = $connection->prepare($sql)) {
              $statement->bind_param("s", $sciname);
              $statement->execute();
              $statement->bind_result($aTID, $tid);
              if ($aTID==NULL) { 
                 $returnvalue = $tid; 
              } else { 
                 $returnvalue = $aTID; 
              }
              $statement->fetch();
              $statement->close();
           }
       }
       return $returnvalue;
   }

   /** 
    * Find the family for a taxa.tid for a scientific name.
    *
    * @param sciname the scientific name, without authorship.
    * @return the taxon.tid for the accepted name, or null if not found.
    */
   public static function lookupFamilyForTID($tid) {
       global $connection;
       $returnvalue = null;
       if ($tid==null) {
           $sql = 'select family from taxstatus where tid = ? ';
           if ($statement = $connection->prepare($sql)) {
              $statement->bind_param("i", $tid);
              $statement->execute();
              $statement->bind_result($returnvalue);
              $statement->fetch();
              $statement->close();
           }
       }
       return $returnvalue;
   }

   private function l_addslashes($value) {
      $retval = $value;
      if (!get_magic_quotes_gpc()) {
          $retval = addslashes($value);
      }
      return $retval;
   }
   private function l_stripslashes($value) {
      $retval = $value;
      if (!get_magic_quotes_gpc()) {
          $retval = stripslashes($value);
      }
      return $retval;
   }
   public function isDirty() {
       return $this->dirty;
   }
   public function isLoaded() {
       return $this->loaded;
   }
   public function errorMessage() {
       return $this->error;
   }

   //---------------------------------------------------------------------------

   public function keyValueSet($fieldname,$value) {
       $returnvalue = false;
       if ($this->hasField($fieldname)) { 
          try {
             if ($fieldname=='detid') { $returnvalue = $this->setdetid($value); } 
             if ($fieldname=='occid') { $returnvalue = $this->setoccid($value); } 
             if ($fieldname=='identifiedBy') { $returnvalue = $this->setidentifiedBy($value); } 
             if ($fieldname=='dateIdentified') { $returnvalue = $this->setdateIdentified($value); } 
             if ($fieldname=='dateIdentifiedInterpreted') { $returnvalue = $this->setdateIdentifiedInterpreted($value); } 
             if ($fieldname=='sciname') { $returnvalue = $this->setsciname($value); } 
             if ($fieldname=='scientificNameAuthorship') { $returnvalue = $this->setscientificNameAuthorship($value); } 
             if ($fieldname=='identificationQualifier') { $returnvalue = $this->setidentificationQualifier($value); } 
             if ($fieldname=='identificationReferences') { $returnvalue = $this->setidentificationReferences($value); }
             if ($fieldname=='printQueue') { $returnvalue = $this->setprintQueue($value); }
             if ($fieldname=='detType') { $returnvalue = $this->setdetType($value); }
             if ($fieldname=='identificationRemarks') { $returnvalue = $this->setidentificationRemarks($value); } 
             if ($fieldname=='sortsequence') { $returnvalue = $this->setsortsequence($value); } 
             if ($fieldname=='initialtimestamp') { $returnvalue = $this->setinitialtimestamp($value); } 
             if ($fieldname=='sourceIdentifier') { $returnvalue = $this->setsourceIdentifier($value); } 
             $returnvalue = true;
          }
          catch (exception $e) { ;
              $returnvalue = false;
              throw new Exception('Field Set Error'.$e->getMessage()); 
          }
       } else { 
          throw new Exception('No Such field'); 
       }  
       return $returnvalue;
   }
   public function keyGet($fieldname) {
       $returnvalue = null;
       if ($this->hasField($fieldname)) { 
          try {
             if ($fieldname=='detid') { $returnvalue = $this->getdetid(); } 
             if ($fieldname=='occid') { $returnvalue = $this->getoccid(); } 
             if ($fieldname=='identifiedBy') { $returnvalue = $this->getidentifiedBy(); } 
             if ($fieldname=='dateIdentified') { $returnvalue = $this->getdateIdentified(); } 
             if ($fieldname=='dateIdentifiedInterpreted') { $returnvalue = $this->getdateIdentifiedInterpreted(); } 
             if ($fieldname=='sciname') { $returnvalue = $this->getsciname(); } 
             if ($fieldname=='scientificNameAuthorship') { $returnvalue = $this->getscientificNameAuthorship(); } 
             if ($fieldname=='identificationQualifier') { $returnvalue = $this->getidentificationQualifier(); } 
             if ($fieldname=='printQueue') { $returnvalue = $this->getprintQueue(); }
             if ($fieldname=='detType') { $returnvalue = $this->getdetType(); }
             if ($fieldname=='identificationReferences') { $returnvalue = $this->getidentificationReferences(); } 
             if ($fieldname=='identificationRemarks') { $returnvalue = $this->getidentificationRemarks(); } 
             if ($fieldname=='sortsequence') { $returnvalue = $this->getsortsequence(); } 
             if ($fieldname=='initialtimestamp') { $returnvalue = $this->getinitialtimestamp(); } 
             if ($fieldname=='sourceIdentifier') { $returnvalue = $this->getsourceIdentifier(); } 
          }
          catch (exception $e) { ;
              $returnvalue = null;
          }
       }
       return $returnvalue;
   }
/*detid*/
   public function getdetid() {
       if ($this->detid==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->detid));
       }
   }
   public function setdetid($detid) {
       if (strlen(preg_replace('/[^0-9]/','',$detid)) > omoccurdeterminations::DETID_SIZE) { 
           throw new Exception('Value has too many digits for the field length.');
       } 
       $detid = trim($detid);
       if (!ctype_digit(strval($detid)) && trim(strval($detid))!='' ) {
             throw new Exception("Value must be an integer");
       }
       $this->detid = $this->l_addslashes($detid);
       $this->dirty = true;
   }
/*occid*/
   public function getoccid() {
       if ($this->occid==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->occid));
       }
   }
   public function setoccid($occid) {
       if (strlen($occid) > omoccurdeterminations::OCCID_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->occid = $this->l_addslashes($occid);
       $this->dirty = true;
   }
/*identifiedBy*/
   public function getidentifiedBy() {
       if ($this->identifiedBy==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->identifiedBy));
       }
   }
   public function setidentifiedBy($identifiedBy) {
       if (strlen($identifiedBy) > omoccurdeterminations::IDENTIFIEDBY_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->identifiedBy = $this->l_addslashes($identifiedBy);
       $this->dirty = true;
   }
/*dateIdentified*/
   public function getdateIdentified() {
       if ($this->dateIdentified==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->dateIdentified));
       }
   }
   public function setdateIdentified($dateIdentified) {
       if (strlen($dateIdentified) > omoccurdeterminations::DATEIDENTIFIED_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->dateIdentified = $this->l_addslashes($dateIdentified);
       $this->dirty = true;
   }
/*dateIdentifiedInterpreted*/
   public function getdateIdentifiedInterpreted() {
       if ($this->dateIdentifiedInterpreted==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->dateIdentifiedInterpreted));
       }
   }
   public function setdateIdentifiedInterpreted($dateIdentifiedInterpreted) {
       if (strlen($dateIdentifiedInterpreted) > omoccurdeterminations::DATEIDENTIFIEDINTERPRETED_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->dateIdentifiedInterpreted = $this->l_addslashes($dateIdentifiedInterpreted);
       $this->dirty = true;
   }
/*sciname*/
   public function getsciname() {
       if ($this->sciname==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->sciname));
       }
   }
   public function setsciname($sciname) {
       if (strlen($sciname) > omoccurdeterminations::SCINAME_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->sciname = $this->l_addslashes($sciname);
       $this->dirty = true;
   }
/*scientificNameAuthorship*/
   public function getscientificNameAuthorship() {
       if ($this->scientificNameAuthorship==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->scientificNameAuthorship));
       }
   }
   public function setscientificNameAuthorship($scientificNameAuthorship) {
       if (strlen($scientificNameAuthorship) > omoccurdeterminations::SCIENTIFICNAMEAUTHORSHIP_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->scientificNameAuthorship = $this->l_addslashes($scientificNameAuthorship);
       $this->dirty = true;
   }
/*identificationQualifier*/
   public function getidentificationQualifier() {
       if ($this->identificationQualifier==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->identificationQualifier));
       }
   }
   public function setidentificationQualifier($identificationQualifier) {
       if (strlen($identificationQualifier) > omoccurdeterminations::IDENTIFICATIONQUALIFIER_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->identificationQualifier = $this->l_addslashes($identificationQualifier);
       $this->dirty = true;
   }
/*identificationReferences*/
   public function getidentificationReferences() {
       if ($this->identificationReferences==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->identificationReferences));
       }
   }
   public function setidentificationReferences($identificationReferences) {
       if (strlen($identificationReferences) > omoccurdeterminations::IDENTIFICATIONREFERENCES_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->identificationReferences = $this->l_addslashes($identificationReferences);
       $this->dirty = true;
   }
/*identificationRemarks*/
   public function getidentificationRemarks() {
       if ($this->identificationRemarks==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->identificationRemarks));
       }
   }
   public function setidentificationRemarks($identificationRemarks) {
       if (strlen($identificationRemarks) > omoccurdeterminations::IDENTIFICATIONREMARKS_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->identificationRemarks = $this->l_addslashes($identificationRemarks);
       $this->dirty = true;
   }
/*sortsequence*/
   public function getsortsequence() {
       if ($this->sortsequence==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->sortsequence));
       }
   }
   public function setsortsequence($sortsequence) {
       if (strlen(preg_replace('/[^0-9]/','',$sortsequence)) > omoccurdeterminations::SORTSEQUENCE_SIZE) { 
           throw new Exception('Value has too many digits for the field length.');
       } 
       $sortsequence = trim($sortsequence);
       if (!ctype_digit(strval($sortsequence)) && trim(strval($sortsequence))!='' ) {
             throw new Exception("Value must be an integer");
       }
       $this->sortsequence = $this->l_addslashes($sortsequence);
       $this->dirty = true;
   }
/*initialtimestamp*/
   public function getinitialtimestamp() {
       if ($this->initialtimestamp==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->initialtimestamp));
       }
   }
   public function setinitialtimestamp($initialtimestamp) {
       if (strlen($initialtimestamp) > omoccurdeterminations::INITIALTIMESTAMP_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->isCurrent = $this->l_addslashes($isCurrent);
       $this->dirty = true;
   }
/*sourceIdentifier*/
   public function getsourceIdentifier() {
       if ($this->sourceIdentifier==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->sourceIdentifier));
       }
   }
   public function setsourceIdentifier($sourceIdentifier) {
       if (strlen(preg_replace('/[^0-9]/','',$sourceIdentifier)) > omoccurdeterminations::SOURCEIDENTIFIER_SIZE) { 
           throw new Exception('Value has too many digits for the field length.');
       } 
       $sourceIdentifier = trim($sourceIdentifier);
       if (!ctype_digit(strval($sourceIdentifier)) && trim(strval($sourceIdentifier))!='' ) {
             throw new Exception("Value must be an integer");
       }
       $this->sourceIdentifier = $this->l_addslashes($sourceIdentifier);
       $this->dirty = true;
   }
/*isCurrent*/
   public function getisCurrent() {
       if ($this->isCurrent==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->isCurrent));
       }
   }
   public function setisCurrent($isCurrent) {
       if (strlen($isCurrent) > omoccurdeterminations::ISCURRENT_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->isCurrent = $this->l_addslashes($isCurrent);
       $this->dirty = true;
   }
/*printQueue*/
   public function getprintQueue() {
       if ($this->printQueue==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->printQueue));
       }
   }
   public function setprintQueue($printQueue) {
       if (strlen($printQueue) > omoccurdeterminations::PRINTQUEUE_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->printQueue = $this->l_addslashes($printQueue);
       $this->dirty = true;
   }
/*idbyid*/
   public function getidbyid() {
       if ($this->idbyid==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->idbyid));
       }
   }
   public function setidbyid($idbyid) {
       if (strlen($idbyid) > omoccurdeterminations::IDBYID_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->idbyid = $this->l_addslashes($idbyid);
       $this->dirty = true;
   }
/*appliedStatus*/
   public function getappliedStatus() {
       if ($this->appliedStatus==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->appliedStatus));
       }
   }
   public function setappliedStatus($appliedStatus) {
       if (strlen($appliedStatus) > omoccurdeterminations::APPLIEDSTATUS_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->appliedStatus = $this->l_addslashes($appliedStatus);
       $this->dirty = true;
   }
/*detType*/
   public function getdetType() {
       if ($this->detType==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->detType));
       }
   }
   public function setdetType($detType) {
       if (strlen($detType) > omoccurdeterminations::DETTYPE_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->detType = $this->l_addslashes($detType);
       $this->dirty = true;
   }
/*tidInterpreted*/
   public function gettidInterpreted() {
       if ($this->tidInterpreted==null) { 
          return null;
       } else { ;
          return trim($this->l_stripslashes($this->tidInterpreted));
       }
   }
   public function settidInterpreted($tidInterpreted) {
       if (strlen($tidInterpreted) > omoccurdeterminations::TIDINTERPRETED_SIZE) { 
           throw new Exception('Value exceeds field length.');
       } 
       $this->tidInterpreted = $this->l_addslashes($tidInterpreted);
       $this->dirty = true;
   }




   public function PK() { // get value of primary key 
        $returnvalue = '';
        $returnvalue .= $this->getdetid();
        return $returnvalue;
   }
   public function PKArray() { // get name and value of primary key fields 
        $returnvalue = array();
        $returnvalue['detid'] = $this->getdetid();
        return $returnvalue;
   }
   public function NumberOfPrimaryKeyFields() { // returns the number of primary key fields defined for this table 
        return 1;
   }

   // Constants holding the mysqli field type character (s,i,d) for each field
  const C_detidMYSQLI_TYPE = 'i';
  const C_occidMYSQLI_TYPE = 'i';
  const C_identifiedByMYSQLI_TYPE = 's';
  const C_dateIdentifiedMYSQLI_TYPE = 's';
  const C_dateIdentifiedInterpretedMYSQLI_TYPE = 's';
  const C_scinameMYSQLI_TYPE = 's';
  const C_scientificNameAuthorshipMYSQLI_TYPE = 's';
  const C_identificationQualifierMYSQLI_TYPE = 's';
  const C_identificationReferencesMYSQLI_TYPE = 's';
  const C_identificationRemarksMYSQLI_TYPE = 's';
  const C_sortsequenceMYSQLI_TYPE = 'i';
  const C_initialtimestampMYSQLI_TYPE = 's';
  const C_idbyidMYSQLI_TYPE = 'i';
  const C_isCurrentMYSQLI_TYPE = 'i';
  const C_printQueueMYSQLI_TYPE = 'i';
  const C_appliedStatusMYSQLI_TYPE = 'i';
  const C_detTypeMYSQLI_TYPE = 's';
  const C_tidInterpretedMYSQLI_TYPE = 'i';
  const C_sourceIdentifierMYSQLI_TYPE = 'is';

   // function to obtain the mysqli field type character from a fieldname
   public function MySQLiFieldType($aFieldname) { 
      $retval = '';
      if ($aFieldname=='detid') { $retval = self::C_detidMYSQLI_TYPE; }
      if ($aFieldname=='occid') { $retval = self::C_occidMYSQLI_TYPE; }
      if ($aFieldname=='identifiedBy') { $retval = self::C_identifiedByMYSQLI_TYPE; }
      if ($aFieldname=='dateIdentified') { $retval = self::C_dateIdentifiedMYSQLI_TYPE; }
      if ($aFieldname=='dateIdentifiedInterpreted') { $retval = self::C_dateIdentifiedInterpretedMYSQLI_TYPE; }
      if ($aFieldname=='sciname') { $retval = self::C_scinameMYSQLI_TYPE; }
      if ($aFieldname=='scientificNameAuthorship') { $retval = self::C_scientificNameAuthorshipMYSQLI_TYPE; }
      if ($aFieldname=='identificationQualifier') { $retval = self::C_identificationQualifierMYSQLI_TYPE; }
      if ($aFieldname=='identificationReferences') { $retval = self::C_identificationReferencesMYSQLI_TYPE; }
      if ($aFieldname=='identificationRemarks') { $retval = self::C_identificationRemarksMYSQLI_TYPE; }
      if ($aFieldname=='sortsequence') { $retval = self::C_sortsequenceMYSQLI_TYPE; }
      if ($aFieldname=='initialtimestamp') { $retval = self::C_initialtimestampMYSQLI_TYPE; }
      if ($aFieldname=='idbyid') { $retval = self::C_idbyidMYSQLI_TYPE; }
      if ($aFieldname=='isCurrent') { $retval = self::C_isCurrentMYSQLI_TYPE; }
      if ($aFieldname=='printQueue') { $retval = self::C_printQueueMYSQLI_TYPE; }
      if ($aFieldname=='appliedStatus') { $retval = self::C_appliedStatusMYSQLI_TYPE; }
      if ($aFieldname=='detType') { $retval = self::C_detTypeMYSQLI_TYPE; }
      if ($aFieldname=='tidInterpreted') { $retval = self::C_tidInterpretedMYSQLI_TYPE; }
      if ($aFieldname=='sourceIdentifier') { $retval = self::C_sourceIdentifierMYSQLI_TYPE; }
      return $retval;
   }

   // Function load() can take either the value of the primary key which uniquely identifies a particular row
   // or an array of array('primarykeyfieldname'=>'value') in the case of a single field primary key
   // or an array of fieldname value pairs in the case of multiple field primary key.
   public function load($pk) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = false;
        try {
             if (is_array($pk)) { 
                 $this->setdetid($pk[detid]);
             } else { ;
                 $this->setdetid($pk);
             };
        } 
        catch (Exception $e) { 
             throw new Exception($e->getMessage());
        }
        if($this->detid != NULL) {
           $sql = 'SELECT detid, occid, identifiedBy, dateIdentified, dateIdentifiedInterpreted, sciname, scientificNameAuthorship, identificationQualifier, identificationReferences, identificationRemarks, sortsequence, initialtimestamp, idbyid, isCurrent, printQueue, appliedStatus, detType, tidInterpreted,sourceIdentifier FROM omoccurdeterminations WHERE detid = '.$this->detid ;

           $preparesql = 'SELECT detid, occid, identifiedBy, dateIdentified, dateIdentifiedInterpreted, sciname, scientificNameAuthorship, identificationQualifier, identificationReferences, identificationRemarks, sortsequence, initialtimestamp, idbyid, isCurrent, printQueue, appliedStatus, detType, tidInterpreted,sourceIdentifier FROM omoccurdeterminations WHERE detid = ? ';

           if ($statement = $connection->prepare($preparesql)) { 
              $statement->bind_param("i", $this->detid);
              $statement->execute();
              $statement->bind_result($this->detid, $this->occid, $this->identifiedBy, $this->dateIdentified, $this->dateIdentifiedInterpreted, $this->sciname, $this->scientificNameAuthorship, $this->identificationQualifier, $this->identificationReferences, $this->identificationRemarks, $this->sortsequence, $this->initialtimestamp, $this->idbyid, $this->isCurrent, $this->printQueue, $this->appliedStatus, $this->detType, $this->tidInterpreted, $this->sourceIdentifier);
              $statement->fetch();
              $statement->close();
           }

            $this->loaded = true;
            $this->dirty = false;
        } else { 
        }
        return $returnvalue;
    }
   //---------------------------------------------------------------------------

   // Function save() will either save the current record or insert a new record.
   // Inserts new record if the primary key field in this table is null 
   // for this instance of this object.
   // Otherwise updates the record identified by the primary key value.
   public function save() {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = false;
        // Test to see if this is an insert or update.
        if ($this->detid!= NULL) {
            $sql  = 'UPDATE  omoccurdeterminations SET ';
            $isInsert = false;
            $sql .=  "occid = ? ";
            $sql .=  ", identifiedBy = ? ";
            $sql .=  ", dateIdentified = ? ";
            $sql .=  ", dateIdentifiedInterpreted = ? ";
            $sql .=  ", sciname = ? ";
            $sql .=  ", scientificNameAuthorship = ? ";
            $sql .=  ", identificationQualifier = ? ";
            $sql .=  ", identificationReferences = ? ";
            $sql .=  ", identificationRemarks = ? ";
            $sql .=  ", sortsequence = ? ";
            $sql .=  ", initialtimestamp = ? ";
            $sql .=  ", idbyid = ? ";
            $sql .=  ", isCurrent = ? ";
            $sql .=  ", printQueue = ? ";
            $sql .=  ", appliedStatus = ? ";
            $sql .=  ", detType = ? ";
            $sql .=  ", tidInterpreted = ? ";
            $sql .=  ", sourceIdentifier = ? ";

            $sql .= "  WHERE detid = ? ";
        } else {
            $sql  = 'INSERT INTO omoccurdeterminations ';
            $isInsert = true;
            $sql .= '( detid ,  occid ,  identifiedBy ,  dateIdentified , dateIdentifiedInterpreted , sciname ,  scientificNameAuthorship ,  identificationQualifier ,  identificationReferences ,  identificationRemarks ,  sortsequence ,  initialtimestamp, idbyid, isCurrent, printQueue, appliedStatus, detType, tidInterpreted, sourceIdentifier ) VALUES (';
            $sql .=  "  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .=  " ,  ? ";
            $sql .= ')';

        }
        if ($statement = $connection->prepare($sql)) { 
           if ($this->detid!= NULL ) {
              $statement->bind_param("iissssssssisiiiisisi", $this->detid , $this->occid , $this->identifiedBy , $this->dateIdentified , $this->dateIdentifiedInterpreted , $this->sciname , $this->scientificNameAuthorship , $this->identificationQualifier , $this->identificationReferences , $this->identificationRemarks , $this->sortsequence , $this->initialtimestamp, $this->idbyid, $this->isCurrent, $this->printQueue, $this->appliedStatus, $this->detType, $this->tidInterpreted , $this->sourceIdentifier  , $this->detid );
           } else { 
              $statement->bind_param("iissssssssisiiiisis", $this->detid , $this->occid , $this->identifiedBy , $this->dateIdentified , $this->dateIdentifiedInterpreted , $this->sciname , $this->scientificNameAuthorship , $this->identificationQualifier , $this->identificationReferences , $this->identificationRemarks , $this->sortsequence , $this->initialtimestamp, $this->idbyid, $this->isCurrent, $this->printQueue, $this->appliedStatus, $this->detType, $this->tidInterpreted, $this->sourceIdentifier  );
           } 
           $statement->execute();
           if ($statement->num_rows()!=1) {
               $this->error = $statement->error; 
           } else { 
              if ($this->detid==NULL) { $this->detid = $statement->insert_id; } 
           }
           $statement->close();
        } else { 
            $this->error = mysqli_error($connection); 
        }
        if ($this->error=='') { 
            $returnvalue = true;
        };

        $this->loaded = true;
        return $returnvalue;
    }
   //---------------------------------------------------------------------------

   public function delete() {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = false;
        if($this->detid != NULL) {

           $preparedsql = 'SELECT detid FROM omoccurdeterminations WHERE detid = ?  ' ;
          if ($statement = $connection->prepare($preparedsql)) {
             $statement->bind_param("i", $this->detid);
             $statement->execute();
             $statement->store_result();
             if ($statement->num_rows()==1) {
                  $sql = 'DELETE FROM omoccurdeterminations WHERE detid = ?  ';
                  if ($stmt_delete = $connection->prepare($sql)) {
                     $stmt_delete->bind_param("i", $this->detid);
                     if ($stmnt_delete->execute()) {
                         $returnvalue = true;
                     } else {
                         $this->error = mysqli_error($connection);
                     }
                     $stmt_delete->close();
                  }
             } else {
                 $this->error = mysqli_error($connection);
             }
             $statement->close();
          } else {
              $this->error = mysqli_error($connection);
          }

            $this->loaded = true;
            // record was deleted, so set PK to null
            $this->detid = NULL;
        } else {
           throw new Exception('Unable to identify which record to delete, primary key is not set');
        }
        return $returnvalue;
    }
   //---------------------------------------------------------------------------

   public function count() {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = false;
        $sql = 'SELECT count(*)  FROM omoccurdeterminations';
        if ($result = $connection->query($sql)) { 
           if ($result->num_rows()==1) {
             $row = $result->fetch_row();
             if ($row) {
                $returnvalue = $row[0];
             }
           }
        } else { 
           $this->error = mysqli_error($connection); 
        }
        mysqli_free_result($result);

        $this->loaded = true;
        return $returnvalue;
    }
   //---------------------------------------------------------------------------

   public function loadArrayKeyValueSearch($searchTermArray) {
       // ******* Note: $connection must be a mysqli object.
       global $connection;
       $returnvalue = array();
       $and = '';
       $wherebit = 'WHERE ';
       foreach($searchTermArray as $fieldname => $searchTerm) {
           if ($this->hasField($fieldname)) { 
               $operator = '='; 
               // change to a like search if a wildcard character is present
               if (!(strpos($searchTerm,'%')===false)) { $operator = 'like'; }
               if (!(strpos($searchTerm,'_')===false)) { $operator = 'like'; }
               if ($searchTerm=='[NULL]') { 
                   $wherebit .= "$and ($fieldname is null or $fieldname='') "; 
               } else { 
                   $wherebit .= "$and $fieldname $operator ? ";
                   $types = $types . $this->MySQLiFieldType($fieldname);
               } 
               $and = ' and ';
           }
       }
       $sql = "SELECT detid FROM omoccurdeterminations $wherebit";
       if ($wherebit=='') { 
             $this->error = 'Error: No search terms provided';
       } else {
          $statement = $connection->prepare($sql);
          $vars = Array();
          $vars[] = $types;
          $i = 0;
          foreach ($searchTermArray as $value) { 
               $varname = 'bind'.$i;  // create a variable name
               $$varname = $value;    // using that variable name store the value 
               $vars[] = &$$varname;  // add a reference to the variable to the array
               $i++;
           }
           //$vars[] contains $types followed by references to variables holding each value in $searchTermArray.
          call_user_func_array(array($statement,'bind_param'),$vars);
          //$statement->bind_param($types,$names);
          $statement->execute();
          $statement->bind_result($id);
          $ids = array();
          while ($statement->fetch()) {
              $ids[] = $id;
          } // double loop to allow all data to be retrieved before preparing a new statement. 
          $statement->close();
          for ($i=0;$i<count($ids);$i++) {
              $obj = new omoccurdeterminations();
              $obj->load($ids[$i]);
              $returnvalue[] = $obj;
              $result=true;
          }
          if ($result===false) { $this->error = mysqli_error($connection); }
       }
       return $returnvalue;
   }	

   //---------------------------------------------------------------------------

// TODO: *************** link to related tables 

   //---------------------------------------------------------------------------


   //---------------------------------------------------------------------------

   // Each field with an index has a load array method generated for it.
   public function loadArrayByoccid($searchTerm) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = array();
        $operator = "=";
        // change to a like search if a wildcard character is present
        if (!(strpos($searchTerm,"%")===false)) { $operator = "like"; }
        if (!(strpos($searchTerm,"_")===false)) { $operator = "like"; }
        $sql = "SELECT detid FROM omoccurdeterminations WHERE occid $operator '$searchTerm'";
        $preparedsql = "SELECT detid FROM omoccurdeterminations WHERE occid $operator ? ";
        if ($statement = $connection->prepare($preparedsql)) { 
            $statement->bind_param("s", $searchTerm);
            $statement->execute();
            $statement->bind_result($id);
            while ($statement->fetch()) { ;
                $obj = new omoccurdeterminations();
                $obj->load($id);
                $returnvalue[] = $obj;
            }
            $statement->close();
        }
        return $returnvalue;
   }
   public function loadArrayByidentifiedBy($searchTerm) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = array();
        $operator = "=";
        // change to a like search if a wildcard character is present
        if (!(strpos($searchTerm,"%")===false)) { $operator = "like"; }
        if (!(strpos($searchTerm,"_")===false)) { $operator = "like"; }
        $sql = "SELECT detid FROM omoccurdeterminations WHERE identifiedBy $operator '$searchTerm'";
        $preparedsql = "SELECT detid FROM omoccurdeterminations WHERE identifiedBy $operator ? ";
        if ($statement = $connection->prepare($preparedsql)) { 
            $statement->bind_param("s", $searchTerm);
            $statement->execute();
            $statement->bind_result($id);
            while ($statement->fetch()) { ;
                $obj = new omoccurdeterminations();
                $obj->load($id);
                $returnvalue[] = $obj;
            }
            $statement->close();
        }
        return $returnvalue;
   }
   public function loadArrayBydateIdentified($searchTerm) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = array();
        $operator = "=";
        // change to a like search if a wildcard character is present
        if (!(strpos($searchTerm,"%")===false)) { $operator = "like"; }
        if (!(strpos($searchTerm,"_")===false)) { $operator = "like"; }
        $sql = "SELECT detid FROM omoccurdeterminations WHERE dateIdentified $operator '$searchTerm'";
        $preparedsql = "SELECT detid FROM omoccurdeterminations WHERE dateIdentified $operator ? ";
        if ($statement = $connection->prepare($preparedsql)) { 
            $statement->bind_param("s", $searchTerm);
            $statement->execute();
            $statement->bind_result($id);
            while ($statement->fetch()) { ;
                $obj = new omoccurdeterminations();
                $obj->load($id);
                $returnvalue[] = $obj;
            }
            $statement->close();
        }
        return $returnvalue;
   }

   //---------------------------------------------------------------------------

   // Each fulltext index has a load array method generated for it.

   //---------------------------------------------------------------------------

   // Each field with an index has a select distinct method generated for it.
   public function selectDistinctoccid($startline,$link,$endline,$includecount=false,$orderbycount=false) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = '';
        $order = ' occid ';
        if ($orderbycount) { $order = ' druid_ct DESC '; } 
        $sql = "SELECT count(*) as druid_ct, occid FROM omoccurdeterminations group by occid order by $order ";
        if ($result = $connection->query($sql)) { 
           while ($row = $result->fetch_row()) {
              if ($row) {
                  $count = $row[0];
                  $val = $row[1];
                  $escaped = urlencode($row[1]);
                  if ($val=='') {
                     $val = '[NULL]'; 
                     $escaped = urlencode('[NULL]');
                  }
                  if ($link=='') { 
                     $returnvalue .= "$startline$val&nbsp;($count)$endline";
                  } else { 
                     $returnvalue .= "$startline<a href='$link&occid=$escaped'>$val</a>&nbsp;($count)$endline";
                  }
              }
           }
           $result->close();
        }
        return $returnvalue;
    }
   public function selectDistinctidentifiedBy($startline,$link,$endline,$includecount=false,$orderbycount=false) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = '';
        $order = ' identifiedBy ';
        if ($orderbycount) { $order = ' druid_ct DESC '; } 
        $sql = "SELECT count(*) as druid_ct, identifiedBy FROM omoccurdeterminations group by identifiedBy order by $order ";
        if ($result = $connection->query($sql)) { 
           while ($row = $result->fetch_row()) {
              if ($row) {
                  $count = $row[0];
                  $val = $row[1];
                  $escaped = urlencode($row[1]);
                  if ($val=='') {
                     $val = '[NULL]'; 
                     $escaped = urlencode('[NULL]');
                  }
                  if ($link=='') { 
                     $returnvalue .= "$startline$val&nbsp;($count)$endline";
                  } else { 
                     $returnvalue .= "$startline<a href='$link&identifiedBy=$escaped'>$val</a>&nbsp;($count)$endline";
                  }
              }
           }
           $result->close();
        }
        return $returnvalue;
    }
   public function selectDistinctdateIdentified($startline,$link,$endline,$includecount=false,$orderbycount=false) {
        // ******* Note: $connection must be a mysqli object.
        global $connection;
        $returnvalue = '';
        $order = ' dateIdentified ';
        if ($orderbycount) { $order = ' druid_ct DESC '; } 
        $sql = "SELECT count(*) as druid_ct, dateIdentified FROM omoccurdeterminations group by dateIdentified order by $order ";
        if ($result = $connection->query($sql)) { 
           while ($row = $result->fetch_row()) {
              if ($row) {
                  $count = $row[0];
                  $val = $row[1];
                  $escaped = urlencode($row[1]);
                  if ($val=='') {
                     $val = '[NULL]'; 
                     $escaped = urlencode('[NULL]');
                  }
                  if ($link=='') { 
                     $returnvalue .= "$startline$val&nbsp;($count)$endline";
                  } else { 
                     $returnvalue .= "$startline<a href='$link&dateIdentified=$escaped'>$val</a>&nbsp;($count)$endline";
                  }
              }
           }
           $result->close();
        }
        return $returnvalue;
    }

   public function keySelectDistinct($fieldname,$startline,$link,$endline,$includecount=false,$orderbycount=false) {
       $returnvalue = '';
       switch ($fieldname) { 
          case 'occid':
             $returnvalue = $this->selectDistinctoccid($startline,$link,$endline,$includecount,$orderbycount);
             break;
          case 'identifiedBy':
             $returnvalue = $this->selectDistinctidentifiedBy($startline,$link,$endline,$includecount,$orderbycount);
             break;
          case 'dateIdentified':
             $returnvalue = $this->selectDistinctdateIdentified($startline,$link,$endline,$includecount,$orderbycount);
             break;
       }
       return $returnvalue;
    }

   //---------------------------------------------------------------------------

   public function hasField($fieldname) {
       $returnvalue = false;
       if (trim($fieldname)!='' && trim($fieldname)!=',') {
            if (strpos(self::FIELDLIST," $fieldname, ")!==false) { 
               $returnvalue = true;
            }
       }
       return $returnvalue;
    }
   //---------------------------------------------------------------------------

}

//==============================================================================
?>